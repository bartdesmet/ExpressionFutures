// Prototyping extended expression trees for C#.
//
// bartde - December 2021

// NB: Running these tests can take a *VERY LONG* time because it invokes the C# compiler for every test
//     case in order to obtain an expression tree object. Be patient when running these tests.

// NB: These tests are generated from a list of expressions in the .tt file by invoking the C# compiler at
//     text template processing time by the T4 engine. See TestUtilities for the helper functions that call
//     into the compiler, load the generated assembly, extract the Expression objects through reflection on
//     the generated type, and call DebugView() on those. The resulting DebugView string is emitted in this
//     file as `expected` variables. The original expression is escaped and gets passed ot the GetDebugView
//     helper method to obtain `actual`, which causes the C# compiler to run at test execution time, using
//     the same helper library, thus obtaining the DebugView string again. This serves a number of goals:
//
//       1. At test generation time, a custom Roslyn build can be invoked to test the implicit conversion
//          of a lambda expression to an expression tree, which involves the changes made to support the
//          C# expression library in this solution. Any fatal compiler errors will come out at that time.
//
//       2. Reflection on the properties in the emitted class causes a deferred execution of the factory
//          method calls generated by the Roslyn compiler for the implicit conversion of the lambda to an
//          expression tree. Any exceptions thrown by the factory methods will show up as well during test
//          generation time, allowing issues to be uncovered.
//
//       3. The string literals in the `expected` variables are inspectable by a human to assert that the
//          compiler has indeed generated an expression representation that's homo-iconic to the original
//          expression that was provided in the test.
//
//       4. Any changes to the compiler or the runtime library could cause regressions. Because template
//          processing of the T4 only takes place upon editing the .tt file, the generated test code won't
//          change. As such, any regression can cause test failures which allows to detect any changes to
//          compiler or runtime library behavior.

using Microsoft.VisualStudio.TestTools.UnitTesting;
using static Tests.Microsoft.CodeAnalysis.CSharp.TestUtilities;

namespace Tests.Microsoft.CodeAnalysis.CSharp
{
    [TestClass]
    public partial class CompilerTests_CSharp90_PatternMatching
    {
        [TestMethod]
        public void CompilerTest_EF4D_84CA()
        {
            // (Expression<Func<object, bool>>)(o => o is > 0)
            var actual = GetDebugView(@"(Expression<Func<object, bool>>)(o => o is > 0)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Object,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <GreaterThanPattern InputType=""System.Object"" NarrowedType=""System.Int32"">
          <Constant Type=""System.Int32"" Value=""0"" />
        </GreaterThanPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_EF4D_84CA();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_EF4D_84CA() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_F939_C326()
        {
            // (Expression<Func<int?,   bool>>)(o => o is > 0)
            var actual = GetDebugView(@"(Expression<Func<int?,   bool>>)(o => o is > 0)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Nullable`1[System.Int32],System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Nullable`1[System.Int32]"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Nullable`1[System.Int32]"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <GreaterThanPattern InputType=""System.Nullable`1[System.Int32]"" NarrowedType=""System.Int32"">
          <Constant Type=""System.Int32"" Value=""0"" />
        </GreaterThanPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_F939_C326();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_F939_C326() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_13ED_00A4()
        {
            // (Expression<Func<int,    bool>>)(o => o is > 0)
            var actual = GetDebugView(@"(Expression<Func<int,    bool>>)(o => o is > 0)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Int32,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Int32"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Int32"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <GreaterThanPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
          <Constant Type=""System.Int32"" Value=""0"" />
        </GreaterThanPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_13ED_00A4();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_13ED_00A4() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_58D1_B6D4()
        {
            // (Expression<Func<long,    bool>>)(o => o is >  1)
            var actual = GetDebugView(@"(Expression<Func<long,    bool>>)(o => o is >  1)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Int64,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Int64"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Int64"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <GreaterThanPattern InputType=""System.Int64"" NarrowedType=""System.Int64"">
          <Constant Type=""System.Int64"" Value=""1"" />
        </GreaterThanPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_58D1_B6D4();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_58D1_B6D4() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_3F05_79B5()
        {
            // (Expression<Func<uint,    bool>>)(o => o is >= 2)
            var actual = GetDebugView(@"(Expression<Func<uint,    bool>>)(o => o is >= 2)");
            var expected = @"
<Lambda Type=""System.Func`2[System.UInt32,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.UInt32"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.UInt32"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <GreaterThanOrEqualPattern InputType=""System.UInt32"" NarrowedType=""System.UInt32"">
          <Constant Type=""System.UInt32"" Value=""2"" />
        </GreaterThanOrEqualPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_3F05_79B5();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_3F05_79B5() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_645C_AE55()
        {
            // (Expression<Func<double,  bool>>)(o => o is <  3.14)
            var actual = GetDebugView(@"(Expression<Func<double,  bool>>)(o => o is <  3.14)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Double,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Double"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Double"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <LessThanPattern InputType=""System.Double"" NarrowedType=""System.Double"">
          <Constant Type=""System.Double"" Value=""3.14"" />
        </LessThanPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_645C_AE55();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_645C_AE55() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_A294_ED2A()
        {
            // (Expression<Func<byte,    bool>>)(o => o is <= 255)
            var actual = GetDebugView(@"(Expression<Func<byte,    bool>>)(o => o is <= 255)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Byte,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Byte"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Byte"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <LessThanOrEqualPattern InputType=""System.Byte"" NarrowedType=""System.Byte"">
          <Constant Type=""System.Byte"" Value=""255"" />
        </LessThanOrEqualPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_A294_ED2A();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_A294_ED2A() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_AD89_871F()
        {
            // (Expression<Func<decimal, bool>>)(o => o is <= 4.95m)
            var actual = GetDebugView(@"(Expression<Func<decimal, bool>>)(o => o is <= 4.95m)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Decimal,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Decimal"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Decimal"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <LessThanOrEqualPattern InputType=""System.Decimal"" NarrowedType=""System.Decimal"">
          <Constant Type=""System.Decimal"" Value=""4.95"" />
        </LessThanOrEqualPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_AD89_871F();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_AD89_871F() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_ADBD_4404()
        {
            // (Expression<Func<object, bool>>)(o => o is >= 0 and < 10)
            var actual = GetDebugView(@"(Expression<Func<object, bool>>)(o => o is >= 0 and < 10)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Object,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <AndPattern InputType=""System.Object"" NarrowedType=""System.Int32"">
          <Left>
            <GreaterThanOrEqualPattern InputType=""System.Object"" NarrowedType=""System.Int32"">
              <Constant Type=""System.Int32"" Value=""0"" />
            </GreaterThanOrEqualPattern>
          </Left>
          <Right>
            <LessThanPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
              <Constant Type=""System.Int32"" Value=""10"" />
            </LessThanPattern>
          </Right>
        </AndPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_ADBD_4404();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_ADBD_4404() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_9DC2_F0F3()
        {
            // (Expression<Func<object, bool>>)(o => o is 42 or 43)
            var actual = GetDebugView(@"(Expression<Func<object, bool>>)(o => o is 42 or 43)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Object,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <OrPattern InputType=""System.Object"" NarrowedType=""System.Int32"">
          <Left>
            <ConstantPattern InputType=""System.Object"" NarrowedType=""System.Int32"">
              <Constant Type=""System.Int32"" Value=""42"" />
            </ConstantPattern>
          </Left>
          <Right>
            <ConstantPattern InputType=""System.Object"" NarrowedType=""System.Int32"">
              <Constant Type=""System.Int32"" Value=""43"" />
            </ConstantPattern>
          </Right>
        </OrPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_9DC2_F0F3();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_9DC2_F0F3() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_0343_2E7E()
        {
            // (Expression<Func<object, bool>>)(o => o is not null)
            var actual = GetDebugView(@"(Expression<Func<object, bool>>)(o => o is not null)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Object,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <NotPattern InputType=""System.Object"" NarrowedType=""System.Object"">
          <Negated>
            <ConstantPattern InputType=""System.Object"" NarrowedType=""System.Object"">
              <Constant Type=""System.Object"" Value=""null"" />
            </ConstantPattern>
          </Negated>
        </NotPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_0343_2E7E();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_0343_2E7E() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_B907_F017()
        {
            // (Expression<Func<object, bool>>)(o => o is not 42)
            var actual = GetDebugView(@"(Expression<Func<object, bool>>)(o => o is not 42)");
            var expected = @"
<Lambda Type=""System.Func`2[System.Object,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <NotPattern InputType=""System.Object"" NarrowedType=""System.Object"">
          <Negated>
            <ConstantPattern InputType=""System.Object"" NarrowedType=""System.Int32"">
              <Constant Type=""System.Int32"" Value=""42"" />
            </ConstantPattern>
          </Negated>
        </NotPattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_B907_F017();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_B907_F017() => INCONCLUSIVE(); }

        partial class Review
        {
            protected void INCONCLUSIVE() { Assert.Inconclusive(); }
        }

        partial class Reviewed : Review
        {
            private void OK() { }
            private void FAIL(string message = "") { Assert.Fail(message); }
        }

        private readonly Reviewed Verify = new Reviewed();
    }

/*
// NB: The code generated below accepts all tests. *DON'T* just copy/paste this to the .Verify.cs file
//     but review the tests one by one. This output is included in case a minor change is made to debug
//     output produced by DebugView() and all hashes are invalidated. In that case, this output can be
//     copied and pasted into .Verify.cs.

namespace Tests.Microsoft.CodeAnalysis.CSharp
{
    partial class CompilerTests_CSharp90_PatternMatching
    {
        partial class Reviewed
        {
            public override void CompilerTest_EF4D_84CA() => OK();
            public override void CompilerTest_F939_C326() => OK();
            public override void CompilerTest_13ED_00A4() => OK();
            public override void CompilerTest_58D1_B6D4() => OK();
            public override void CompilerTest_3F05_79B5() => OK();
            public override void CompilerTest_645C_AE55() => OK();
            public override void CompilerTest_A294_ED2A() => OK();
            public override void CompilerTest_AD89_871F() => OK();
            public override void CompilerTest_ADBD_4404() => OK();
            public override void CompilerTest_9DC2_F0F3() => OK();
            public override void CompilerTest_0343_2E7E() => OK();
            public override void CompilerTest_B907_F017() => OK();
        }
    }
}
*/
}
