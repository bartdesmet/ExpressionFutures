// Prototyping extended expression trees for C#.
//
// bartde - December 2021

// NB: Running these tests can take a *VERY LONG* time because it invokes the C# compiler for every test
//     case in order to obtain an expression tree object. Be patient when running these tests.

// NB: These tests are generated from a list of expressions in the .tt file by invoking the C# compiler at
//     text template processing time by the T4 engine. See TestUtilities for the helper functions that call
//     into the compiler, load the generated assembly, extract the Expression objects through reflection on
//     the generated type, and call DebugView() on those. The resulting DebugView string is emitted in this
//     file as `expected` variables. The original expression is escaped and gets passed ot the GetDebugView
//     helper method to obtain `actual`, which causes the C# compiler to run at test execution time, using
//     the same helper library, thus obtaining the DebugView string again. This serves a number of goals:
//
//       1. At test generation time, a custom Roslyn build can be invoked to test the implicit conversion
//          of a lambda expression to an expression tree, which involves the changes made to support the
//          C# expression library in this solution. Any fatal compiler errors will come out at that time.
//
//       2. Reflection on the properties in the emitted class causes a deferred execution of the factory
//          method calls generated by the Roslyn compiler for the implicit conversion of the lambda to an
//          expression tree. Any exceptions thrown by the factory methods will show up as well during test
//          generation time, allowing issues to be uncovered.
//
//       3. The string literals in the `expected` variables are inspectable by a human to assert that the
//          compiler has indeed generated an expression representation that's homo-iconic to the original
//          expression that was provided in the test.
//
//       4. Any changes to the compiler or the runtime library could cause regressions. Because template
//          processing of the T4 only takes place upon editing the .tt file, the generated test code won't
//          change. As such, any regression can cause test failures which allows to detect any changes to
//          compiler or runtime library behavior.

using Xunit;
using static Tests.Microsoft.CodeAnalysis.CSharp.TestUtilities;

namespace Tests.Microsoft.CodeAnalysis.CSharp
{
    public partial class CompilerTests_CSharp80_PatternMatching
    {
        [Fact]
        public void CompilerTest_DED2_7DBC()
        {
            // (Expression<Func<(int, string), bool>>)(o => o is (1, "bar"))
            var actual = GetDebugView(@"(Expression<Func<(int, string), bool>>)(o => o is (1, ""bar""))");
            var expected = @"
<Lambda Type=""System.Func`2[System.ValueTuple`2[System.Int32,System.String],System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.ValueTuple`2[System.Int32,System.String]"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.ValueTuple`2[System.Int32,System.String]"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <RecursivePattern InputType=""System.ValueTuple`2[System.Int32,System.String]"" NarrowedType=""System.ValueTuple`2[System.Int32,System.String]"">
          <Deconstruction>
            <Positional>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
            <Positional>
              <Pattern>
                <ConstantPattern InputType=""System.String"" NarrowedType=""System.String"">
                  <Constant Type=""System.String"" Value=""bar"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
          </Deconstruction>
        </RecursivePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_DED2_7DBC();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_DED2_7DBC() => INCONCLUSIVE(); }

        [Fact]
        public void CompilerTest_D281_A3B2()
        {
            // (Expression<Func<(int x, string s), bool>>)(o => o is (x: 1, s: "bar"))
            var actual = GetDebugView(@"(Expression<Func<(int x, string s), bool>>)(o => o is (x: 1, s: ""bar""))");
            var expected = @"
<Lambda Type=""System.Func`2[System.ValueTuple`2[System.Int32,System.String],System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.ValueTuple`2[System.Int32,System.String]"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.ValueTuple`2[System.Int32,System.String]"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <RecursivePattern InputType=""System.ValueTuple`2[System.Int32,System.String]"" NarrowedType=""System.ValueTuple`2[System.Int32,System.String]"">
          <Deconstruction>
            <Positional>
              <Field Name=""x"" Index=""0"" />
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
            <Positional>
              <Field Name=""s"" Index=""1"" />
              <Pattern>
                <ConstantPattern InputType=""System.String"" NarrowedType=""System.String"">
                  <Constant Type=""System.String"" Value=""bar"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
          </Deconstruction>
        </RecursivePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_D281_A3B2();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_D281_A3B2() => INCONCLUSIVE(); }

        [Fact]
        public void CompilerTest_650A_479E()
        {
            // (Expression<Func<Point, bool>>)(o => o is (1, 2))
            var actual = GetDebugView(@"(Expression<Func<Point, bool>>)(o => o is (1, 2))");
            var expected = @"
<Lambda Type=""System.Func`2[Point,System.Boolean]"">
  <Parameters>
    <Parameter Type=""Point"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""Point"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <RecursivePattern InputType=""Point"" NarrowedType=""Point"" DeconstructMethod=""Void Deconstruct(Int32 ByRef, Int32 ByRef)"">
          <Deconstruction>
            <Positional>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
            <Positional>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""2"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
          </Deconstruction>
        </RecursivePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_650A_479E();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_650A_479E() => INCONCLUSIVE(); }

        [Fact]
        public void CompilerTest_9402_3821()
        {
            // (Expression<Func<Point, bool>>)(o => o is (x: 1, y: 2))
            var actual = GetDebugView(@"(Expression<Func<Point, bool>>)(o => o is (x: 1, y: 2))");
            var expected = @"
<Lambda Type=""System.Func`2[Point,System.Boolean]"">
  <Parameters>
    <Parameter Type=""Point"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""Point"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <RecursivePattern InputType=""Point"" NarrowedType=""Point"" DeconstructMethod=""Void Deconstruct(Int32 ByRef, Int32 ByRef)"">
          <Deconstruction>
            <Positional Parameter=""Int32&amp; x"">
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
            <Positional Parameter=""Int32&amp; y"">
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""2"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
          </Deconstruction>
        </RecursivePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_9402_3821();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_9402_3821() => INCONCLUSIVE(); }

        [Fact]
        public void CompilerTest_0D16_94A2()
        {
            // (Expression<Func<Point2D, bool>>)(o => o is (1, 2))
            var actual = GetDebugView(@"(Expression<Func<Point2D, bool>>)(o => o is (1, 2))");
            var expected = @"
<Lambda Type=""System.Func`2[Point2D,System.Boolean]"">
  <Parameters>
    <Parameter Type=""Point2D"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""Point2D"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <RecursivePattern InputType=""Point2D"" NarrowedType=""Point2D"" DeconstructMethod=""Void Deconstruct(Point2D ByRef, Int32 ByRef, Int32 ByRef)"">
          <Deconstruction>
            <Positional>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
            <Positional>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""2"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
          </Deconstruction>
        </RecursivePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_0D16_94A2();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_0D16_94A2() => INCONCLUSIVE(); }

        [Fact]
        public void CompilerTest_C5CA_8C03()
        {
            // (Expression<Func<Point2D, bool>>)(o => o is (x: 1, y: 2))
            var actual = GetDebugView(@"(Expression<Func<Point2D, bool>>)(o => o is (x: 1, y: 2))");
            var expected = @"
<Lambda Type=""System.Func`2[Point2D,System.Boolean]"">
  <Parameters>
    <Parameter Type=""Point2D"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""Point2D"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <RecursivePattern InputType=""Point2D"" NarrowedType=""Point2D"" DeconstructMethod=""Void Deconstruct(Point2D ByRef, Int32 ByRef, Int32 ByRef)"">
          <Deconstruction>
            <Positional Parameter=""Int32&amp; x"">
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
            <Positional Parameter=""Int32&amp; y"">
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""2"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
          </Deconstruction>
        </RecursivePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_C5CA_8C03();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_C5CA_8C03() => INCONCLUSIVE(); }

        [Fact]
        public void CompilerTest_6693_5ADB()
        {
            // (Expression<Func<object, bool>>)(o => o is (1, "bar"))
            var actual = GetDebugView(@"(Expression<Func<object, bool>>)(o => o is (1, ""bar""))");
            var expected = @"
<Lambda Type=""System.Func`2[System.Object,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <ITuplePattern InputType=""System.Object"" NarrowedType=""System.Runtime.CompilerServices.ITuple"" GetLengthMethod=""Int32 get_Length()"" GetItemMethod=""System.Object get_Item(Int32)"">
          <Deconstruction>
            <Positional>
              <Pattern>
                <ConstantPattern InputType=""System.Object"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
            <Positional>
              <Pattern>
                <ConstantPattern InputType=""System.Object"" NarrowedType=""System.String"">
                  <Constant Type=""System.String"" Value=""bar"" />
                </ConstantPattern>
              </Pattern>
            </Positional>
          </Deconstruction>
        </ITuplePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_6693_5ADB();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_6693_5ADB() => INCONCLUSIVE(); }

        [Fact]
        public void CompilerTest_6496_E347()
        {
            // (Expression<Func<object, bool>>)(o => o is Point { X: 0 })
            var actual = GetDebugView(@"(Expression<Func<object, bool>>)(o => o is Point { X: 0 })");
            var expected = @"
<Lambda Type=""System.Func`2[System.Object,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <RecursivePattern InputType=""System.Object"" NarrowedType=""Point"" Type=""Point"">
          <Properties>
            <Property>
              <Member>
                <PropertyCSharpSubpatternMember Member=""Int32 X"" />
              </Member>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""0"" />
                </ConstantPattern>
              </Pattern>
            </Property>
          </Properties>
        </RecursivePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_6496_E347();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_6496_E347() => INCONCLUSIVE(); }

        [Fact]
        public void CompilerTest_2EDD_999F()
        {
            // (Expression<Func<object, bool>>)(o => o is Point { X: 0, Y: 1 })
            var actual = GetDebugView(@"(Expression<Func<object, bool>>)(o => o is Point { X: 0, Y: 1 })");
            var expected = @"
<Lambda Type=""System.Func`2[System.Object,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <RecursivePattern InputType=""System.Object"" NarrowedType=""Point"" Type=""Point"">
          <Properties>
            <Property>
              <Member>
                <PropertyCSharpSubpatternMember Member=""Int32 X"" />
              </Member>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""0"" />
                </ConstantPattern>
              </Pattern>
            </Property>
            <Property>
              <Member>
                <PropertyCSharpSubpatternMember Member=""Int32 Y"" />
              </Member>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Property>
          </Properties>
        </RecursivePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_2EDD_999F();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_2EDD_999F() => INCONCLUSIVE(); }

        [Fact]
        public void CompilerTest_0ACF_C204()
        {
            // (Expression<Func<object, bool>>)(o => o is Point { Y: 1, X: 1 })
            var actual = GetDebugView(@"(Expression<Func<object, bool>>)(o => o is Point { Y: 1, X: 1 })");
            var expected = @"
<Lambda Type=""System.Func`2[System.Object,System.Boolean]"">
  <Parameters>
    <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
  </Parameters>
  <Body>
    <CSharpIsPattern Type=""System.Boolean"">
      <Expression>
        <Parameter Type=""System.Object"" Id=""0"" Name=""o"" />
      </Expression>
      <Pattern>
        <RecursivePattern InputType=""System.Object"" NarrowedType=""Point"" Type=""Point"">
          <Properties>
            <Property>
              <Member>
                <PropertyCSharpSubpatternMember Member=""Int32 Y"" />
              </Member>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Property>
            <Property>
              <Member>
                <PropertyCSharpSubpatternMember Member=""Int32 X"" />
              </Member>
              <Pattern>
                <ConstantPattern InputType=""System.Int32"" NarrowedType=""System.Int32"">
                  <Constant Type=""System.Int32"" Value=""1"" />
                </ConstantPattern>
              </Pattern>
            </Property>
          </Properties>
        </RecursivePattern>
      </Pattern>
    </CSharpIsPattern>
  </Body>
</Lambda>";
            Assert.Equal(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_0ACF_C204();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_0ACF_C204() => INCONCLUSIVE(); }

        partial class Review
        {
            protected void INCONCLUSIVE() { /* Assert.Inconclusive(); */ Assert.True(false, "INCONCLUSIVE"); }
        }

        partial class Reviewed : Review
        {
            private void OK() { }
            private void FAIL(string message = "") { Assert.True(false, message); }
        }

        private readonly Reviewed Verify = new Reviewed();
    }

/*
// NB: The code generated below accepts all tests. *DON'T* just copy/paste this to the .Verify.cs file
//     but review the tests one by one. This output is included in case a minor change is made to debug
//     output produced by DebugView() and all hashes are invalidated. In that case, this output can be
//     copied and pasted into .Verify.cs.

namespace Tests.Microsoft.CodeAnalysis.CSharp
{
    partial class CompilerTests_CSharp80_PatternMatching
    {
        partial class Reviewed
        {
            public override void CompilerTest_DED2_7DBC() => OK();
            public override void CompilerTest_D281_A3B2() => OK();
            public override void CompilerTest_650A_479E() => OK();
            public override void CompilerTest_9402_3821() => OK();
            public override void CompilerTest_0D16_94A2() => OK();
            public override void CompilerTest_C5CA_8C03() => OK();
            public override void CompilerTest_6693_5ADB() => OK();
            public override void CompilerTest_6496_E347() => OK();
            public override void CompilerTest_2EDD_999F() => OK();
            public override void CompilerTest_0ACF_C204() => OK();
        }
    }
}
*/
}
