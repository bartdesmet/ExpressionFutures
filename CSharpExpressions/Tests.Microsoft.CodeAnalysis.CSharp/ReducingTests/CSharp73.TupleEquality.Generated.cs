// Prototyping extended expression trees for C#.
//
// bartde - November 2015

// NB: Running these tests can take a *VERY LONG* time because it invokes the C# compiler for every test
//     case in order to obtain an expression tree object. Be patient when running these tests.

// NB: These tests are generated from a list of expressions in the .tt file by invoking the C# compiler at
//     text template processing time by the T4 engine. See TestUtilities for the helper functions that call
//     into the compiler, load the generated assembly, extract the Expression objects through reflection on
//     the generated type, and call DebugView() on those. The resulting DebugView string is emitted in this
//     file as `expected` variables. The original expression is escaped and gets passed ot the GetDebugView
//     helper method to obtain `actual`, which causes the C# compiler to run at test execution time, using
//     the same helper library, thus obtaining the DebugView string again. This serves a number of goals:
//
//       1. At test generation time, a custom Roslyn build can be invoked to test the implicit conversion
//          of a lambda expression to an expression tree, which involves the changes made to support the
//          C# expression library in this solution. Any fatal compiler errors will come out at that time.
//
//       2. Reflection on the properties in the emitted class causes a deferred execution of the factory
//          method calls generated by the Roslyn compiler for the implicit conversion of the lambda to an
//          expression tree. Any exceptions thrown by the factory methods will show up as well during test
//          generation time, allowing issues to be uncovered.
//
//       3. The string literals in the `expected` variables are inspectable by a human to assert that the
//          compiler has indeed generated an expression representation that's homo-iconic to the original
//          expression that was provided in the test.
//
//       4. Any changes to the compiler or the runtime library could cause regressions. Because template
//          processing of the T4 only takes place upon editing the .tt file, the generated test code won't
//          change. As such, any regression can cause test failures which allows to detect any changes to
//          compiler or runtime library behavior.

using Microsoft.VisualStudio.TestTools.UnitTesting;
using static Tests.Microsoft.CodeAnalysis.CSharp.TestUtilities;

namespace Tests.Microsoft.CodeAnalysis.CSharp
{
    [TestClass]
    public partial class CompilerTests_CSharp73_TupleEquality_Reducing
    {
        [TestMethod]
        public void CompilerTest_E117_F776()
        {
            // (Expression<Func<bool>>)(() => (1, 2) == (3, 4))
            var actual = ToCSharp(@"(Expression<Func<bool>>)(() => (1, 2) == (3, 4))", reduce: true);
            var expected = @"
() => 1 == 3 && 2 == 4";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_E117_F776();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_E117_F776() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_F202_FB1D()
        {
            // (Expression<Func<bool>>)(() => (1, int.Parse("2")) != (int.Parse("3"), 4))
            var actual = ToCSharp(@"(Expression<Func<bool>>)(() => (1, int.Parse(""2"")) != (int.Parse(""3""), 4))", reduce: true);
            var expected = @"
() =>
{
    int __left1, __right0;
    __left1 = int.Parse(""2"");
    __right0 = int.Parse(""3"");
    return 1 != __right0 || __left1 != 4;
}";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_F202_FB1D();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_F202_FB1D() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_9411_0D00()
        {
            // (Expression<Func<(int, int), bool>>)(t => t == (3, 4))
            var actual = ToCSharp(@"(Expression<Func<(int, int), bool>>)(t => t == (3, 4))", reduce: true);
            var expected = @"
((int, int) t) =>
{
    (int, int) __left;
    __left = t;
    return __left.Item1 == 3 && __left.Item2 == 4;
}";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_9411_0D00();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_9411_0D00() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_36A3_3E5F()
        {
            // (Expression<Func<(int, int), bool>>)(t => (1, 2) != t)
            var actual = ToCSharp(@"(Expression<Func<(int, int), bool>>)(t => (1, 2) != t)", reduce: true);
            var expected = @"
((int, int) t) =>
{
    (int, int) __right;
    __right = t;
    return 1 != __right.Item1 || 2 != __right.Item2;
}";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_36A3_3E5F();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_36A3_3E5F() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_B5AA_125F()
        {
            // (Expression<Func<bool>>)(() => (1, (true, "foo")) == (3, (false, "bar")))
            var actual = ToCSharp(@"(Expression<Func<bool>>)(() => (1, (true, ""foo"")) == (3, (false, ""bar"")))", reduce: true);
            var expected = @"
() => 1 == 3 && true == false && ""foo"" == ""bar""";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_B5AA_125F();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_B5AA_125F() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_02A6_E636()
        {
            // (Expression<Func<bool>>)(() => (int.Parse("1"), (true, "foo".ToUpper())) != (3, ("qux".StartsWith("z"), "bar")))
            var actual = ToCSharp(@"(Expression<Func<bool>>)(() => (int.Parse(""1""), (true, ""foo"".ToUpper())) != (3, (""qux"".StartsWith(""z""), ""bar"")))", reduce: true);
            var expected = @"
() =>
{
    int __left0;
    string __left1_1;
    bool __right1_0;
    __left0 = int.Parse(""1"");
    __left1_1 = ""foo"".ToUpper();
    __right1_0 = ""qux"".StartsWith(""z"");
    return __left0 != 3 || true != __right1_0 || __left1_1 != ""bar"";
}";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_02A6_E636();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_02A6_E636() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_0830_8FE6()
        {
            // (Expression<Func<(bool, string), bool>>)(t => (1, t) == (3, (false, "bar")))
            var actual = ToCSharp(@"(Expression<Func<(bool, string), bool>>)(t => (1, t) == (3, (false, ""bar"")))", reduce: true);
            var expected = @"
((bool, string) t) =>
{
    (bool, string) __left1;
    __left1 = t;
    return 1 == 3 && __left1.Item1 == false && __left1.Item2 == ""bar"";
}";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_0830_8FE6();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_0830_8FE6() => INCONCLUSIVE(); }

        [TestMethod]
        public void CompilerTest_B038_1EAB()
        {
            // (Expression<Func<(bool, string), bool>>)(t => (1, (true, "foo")) != (3, t))
            var actual = ToCSharp(@"(Expression<Func<(bool, string), bool>>)(t => (1, (true, ""foo"")) != (3, t))", reduce: true);
            var expected = @"
((bool, string) t) =>
{
    (bool, string) __right1;
    __right1 = t;
    return 1 != 3 || true != __right1.Item1 || ""foo"" != __right1.Item2;
}";
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_B038_1EAB();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_B038_1EAB() => INCONCLUSIVE(); }

        partial class Review
        {
            protected void INCONCLUSIVE() { Assert.Inconclusive(); }
        }

        partial class Reviewed : Review
        {
            private void OK() { }
            private void FAIL(string message = "") { Assert.Fail(message); }
        }

        private readonly Reviewed Verify = new Reviewed();
    }

/*
// NB: The code generated below accepts all tests. *DON'T* just copy/paste this to the .Verify.cs file
//     but review the tests one by one. This output is included in case a minor change is made to debug
//     output produced by DebugView() and all hashes are invalidated. In that case, this output can be
//     copied and pasted into .Verify.cs.

namespace Tests.Microsoft.CodeAnalysis.CSharp
{
    partial class CompilerTests_CSharp73_TupleEquality_Reducing
    {
        partial class Reviewed
        {
            public override void CompilerTest_E117_F776() => OK();
            public override void CompilerTest_F202_FB1D() => OK();
            public override void CompilerTest_9411_0D00() => OK();
            public override void CompilerTest_36A3_3E5F() => OK();
            public override void CompilerTest_B5AA_125F() => OK();
            public override void CompilerTest_02A6_E636() => OK();
            public override void CompilerTest_0830_8FE6() => OK();
            public override void CompilerTest_B038_1EAB() => OK();
        }
    }
}
*/
}
