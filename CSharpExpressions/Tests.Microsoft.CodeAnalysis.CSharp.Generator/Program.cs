// Prototyping extended expression trees for C#.
//
// bartde - September 2022

// NB: This executable gets invoked by T4 templates to generate test code.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Text;
using Tests.Microsoft.CodeAnalysis.CSharp;

namespace PlaygroundCore
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                var path = Environment.ProcessPath;
                var psi = new ProcessStartInfo(path, "test false false")
                {
                    RedirectStandardInput = true,
                    RedirectStandardOutput = true
                };

                var p = Process.Start(psi);

                var input = p.StandardInput;
                var output = p.StandardOutput;

                input.WriteLine("(Expression<Func<int>>)(() => 42)");
                input.WriteLine();

                var res = output.ReadToEnd();

                Console.WriteLine(res);

                return;
            }

            var name = args[0];

            bool csharp = false;
            bool reduce = false;

            if (args.Length >= 3)
            {
                csharp = bool.Parse(args[1]);
                reduce = bool.Parse(args[2]);
            }

            Generate(name, ReadExpressions(), csharp, reduce);

            static IEnumerable<string> ReadExpressions()
            {
                while (true)
                {
                    string line = Console.ReadLine();

                    if (string.IsNullOrEmpty(line))
                    {
                        break;
                    }

                    yield return line;
                }
            }
        }

        static void Generate(string name, IEnumerable<string> exprs, bool generateCSharp, bool reduce)
        {
            var all = new List<string>();
            var toEscapedString = new Func<object, bool, string>((o, multiLine) => "@\"" + (multiLine ? "\r\n" : "") + o.ToString().Replace("\"", "\"\"") + "\"");
            var md5 = System.Security.Cryptography.MD5.Create();
            var getHash = new Func<string, string>(input =>
            {
                var inputBytes = Encoding.ASCII.GetBytes(input);
                var hash = md5.ComputeHash(inputBytes);

                var sb = new StringBuilder();
                for (var b = hash.Length - 2; b < hash.Length; b++)
                {
                    sb.Append(hash[b].ToString("X2"));
                }

                return sb.ToString();
            });

            Console.WriteLine("// NB: Running these tests can take a *VERY LONG* time because it invokes the C# compiler for every test");
            Console.WriteLine("//     case in order to obtain an expression tree object. Be patient when running these tests.");
            Console.WriteLine();
            Console.WriteLine("// NB: These tests are generated from a list of expressions in the .tt file by invoking the C# compiler at");
            Console.WriteLine("//     text template processing time by the T4 engine. See TestUtilities for the helper functions that call");
            Console.WriteLine("//     into the compiler, load the generated assembly, extract the Expression objects through reflection on");
            Console.WriteLine("//     the generated type, and call DebugView() on those. The resulting DebugView string is emitted in this");
            Console.WriteLine("//     file as `expected` variables. The original expression is escaped and gets passed ot the GetDebugView");
            Console.WriteLine("//     helper method to obtain `actual`, which causes the C# compiler to run at test execution time, using");
            Console.WriteLine("//     the same helper library, thus obtaining the DebugView string again. This serves a number of goals:");
            Console.WriteLine("//");
            Console.WriteLine("//       1. At test generation time, a custom Roslyn build can be invoked to test the implicit conversion");
            Console.WriteLine("//          of a lambda expression to an expression tree, which involves the changes made to support the");
            Console.WriteLine("//          C# expression library in this solution. Any fatal compiler errors will come out at that time.");
            Console.WriteLine("//");
            Console.WriteLine("//       2. Reflection on the properties in the emitted class causes a deferred execution of the factory");
            Console.WriteLine("//          method calls generated by the Roslyn compiler for the implicit conversion of the lambda to an");
            Console.WriteLine("//          expression tree. Any exceptions thrown by the factory methods will show up as well during test");
            Console.WriteLine("//          generation time, allowing issues to be uncovered.");
            Console.WriteLine("//");
            Console.WriteLine("//       3. The string literals in the `expected` variables are inspectable by a human to assert that the");
            Console.WriteLine("//          compiler has indeed generated an expression representation that's homo-iconic to the original");
            Console.WriteLine("//          expression that was provided in the test.");
            Console.WriteLine("//");
            Console.WriteLine("//       4. Any changes to the compiler or the runtime library could cause regressions. Because template");
            Console.WriteLine("//          processing of the T4 only takes place upon editing the .tt file, the generated test code won't");
            Console.WriteLine("//          change. As such, any regression can cause test failures which allows to detect any changes to");
            Console.WriteLine("//          compiler or runtime library behavior.");
            Console.WriteLine();

            Console.WriteLine(@"using Xunit;");
            Console.WriteLine(@"using static Tests.Microsoft.CodeAnalysis.CSharp.TestUtilities;");
            Console.WriteLine();
            Console.WriteLine(@"namespace Tests.Microsoft.CodeAnalysis.CSharp");
            Console.WriteLine(@"{");
            Console.WriteLine(@"    public partial class CompilerTests_" + name);
            Console.WriteLine(@"    {");

            var i = 0;
            foreach (var expr in exprs)
            {
                var dbgTest = default(string);
                var ignore = default(string);
                try
                {
                    if (generateCSharp)
                    {
                        dbgTest = TestUtilities.ToCSharp(expr, reduce);
                    }
                    else
                    {
                        dbgTest = TestUtilities.GetDebugView(expr);
                    }
                }
                catch (InvalidProgramException ex)
                {
                    dbgTest = " ???";
                    ignore = ex.Message;
                    ignore += "\r\n" + ex.StackTrace;
                }
                catch (TargetInvocationException ex)
                {
                    dbgTest = "???";
                    ignore = ex.InnerException.Message;
                    ignore += "\r\n" + ex.StackTrace;
                }

                var skip = "";
                if (ignore != null)
                {
                    foreach (var line in ignore.Split('\n'))
                    {
                        Console.WriteLine(@"        // " + line.TrimEnd('\r'));
                    }

                    skip = "(Skip = \"Failed to compile\")";
                }

                var exprHash = getHash(expr);
                var dbgTestHash = getHash(dbgTest);

                // NB: Including a hash of the outcome; it anything changes, compilation will fail in Verify.cs,
                //     forcing a human review of all tests again.
                var id = exprHash + "_" + dbgTestHash;
                all.Add(id);

                Console.WriteLine($@"        [Fact{skip}]");
                Console.WriteLine($@"        public void CompilerTest_{id}()");
                Console.WriteLine($@"        {{");
                Console.WriteLine($@"            // {expr}");

                if (generateCSharp)
                {
                    Console.WriteLine($@"            var actual = ToCSharp({toEscapedString(expr, false)}, reduce: {(reduce ? "true" : "false")});");
                }
                else
                {
                    Console.WriteLine($@"            var actual = GetDebugView({toEscapedString(expr, false)});");
                }

                Console.WriteLine($@"            var expected = {toEscapedString(dbgTest, true)};");
                Console.WriteLine($@"            Assert.Equal(expected.TrimStart('\r', '\n'), actual);");
                Console.WriteLine($@"            Verify.CompilerTest_{id}();");
                Console.WriteLine($@"        }}");
                Console.WriteLine();
                Console.WriteLine($@"        partial class Review {{ /* override in .Verify.cs */ public virtual void CompilerTest_{id}() => INCONCLUSIVE(); }}");

                Console.WriteLine();

                i++;
            }

            Console.WriteLine(@"        partial class Review");
            Console.WriteLine(@"        {");
            Console.WriteLine(@"            protected void INCONCLUSIVE() { /* Assert.Inconclusive(); */ Assert.True(false, ""INCONCLUSIVE""); }");
            Console.WriteLine(@"        }");
            Console.WriteLine();
            Console.WriteLine(@"        partial class Reviewed : Review");
            Console.WriteLine(@"        {");
            Console.WriteLine(@"            private void OK() { }");
            Console.WriteLine(@"            private void FAIL(string message = """") { Assert.True(false, message); }");
            Console.WriteLine(@"        }");
            Console.WriteLine();
            Console.WriteLine(@"        private readonly Reviewed Verify = new Reviewed();");

            Console.WriteLine(@"    }");

            Console.WriteLine();

            Console.WriteLine("/*");
            Console.WriteLine("// NB: The code generated below accepts all tests. *DON'T* just copy/paste this to the .Verify.cs file");
            Console.WriteLine("//     but review the tests one by one. This output is included in case a minor change is made to debug");
            Console.WriteLine("//     output produced by DebugView() and all hashes are invalidated. In that case, this output can be");
            Console.WriteLine("//     copied and pasted into .Verify.cs.");
            Console.WriteLine();
            Console.WriteLine("namespace Tests.Microsoft.CodeAnalysis.CSharp");
            Console.WriteLine("{");
            Console.WriteLine("    partial class CompilerTests_" + name);
            Console.WriteLine("    {");
            Console.WriteLine("        partial class Reviewed");
            Console.WriteLine("        {");

            foreach (var test in all)
            {
                Console.WriteLine($"            public override void CompilerTest_{test}() => OK();");
            }

            Console.WriteLine("        }");
            Console.WriteLine("    }");
            Console.WriteLine("}");
            Console.WriteLine("*/");

            Console.WriteLine(@"}");
        }
    }
}
