// Prototyping extended expression trees for C#.
//
// bartde - October 2015

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var errors = new[]
{
    new { Name = "ParameterNotDefinedForMethod", ExceptionType = "ArgumentException", Args = 2, Message = "Parameter '{0}' is not defined for method '{1}'" },
    new { Name = "ParameterIndexOutOfBounds", ExceptionType = "ArgumentException", Args = 2, Message = "Parameter index '{0}' is out of bounds for method '{1}'" },
    new { Name = "ExpressionTypeDoesNotMatchParameter", ExceptionType = "ArgumentException", Args = 2, Message = "Expression of type '{0}' cannot be used for parameter of type '{1}'" },
    new { Name = "DuplicateParameterBinding", ExceptionType = "ArgumentException", Args = 1, Message = "Parameter '{0}' has multiple bindings" },
    new { Name = "UnboundParameter", ExceptionType = "ArgumentException", Args = 1, Message = "Non-optional parameter '{0}' has no binding" },
    new { Name = "NonStaticConstructorRequired", ExceptionType = "ArgumentException", Args = 0, Message = "A non-static constructor is required" },
    new { Name = "PropertyDoesNotHaveGetAccessor", ExceptionType = "ArgumentException", Args = 1, Message = "The property '{0}' has no 'get' accessor" },
    new { Name = "PropertyDoesNotHaveSetAccessor", ExceptionType = "ArgumentException", Args = 1, Message = "The property '{0}' has no 'set' accessor" },
    new { Name = "AccessorCannotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "A non-static 'get' accessor is required for property '{0}'" },
    new { Name = "RankMismatch", ExceptionType = "ArgumentException", Args = 0, Message = "The number of indexes specified does not match the array rank" },
    new { Name = "IndexOutOfRange", ExceptionType = "ArgumentOutOfRangeException", Args = 0, Message = "The specified index is out of range" },
    new { Name = "BoundCannotBeLessThanZero", ExceptionType = "ArgumentException", Args = 0, Message = "An array dimension cannot be less than 0" },
    new { Name = "ArrayBoundsElementCountMismatch", ExceptionType = "ArgumentException", Args = 0, Message = "The number of elements does not match the length of the array" },
    new { Name = "GetAwaiterShouldTakeZeroParameters", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetAwaiter' method should take zero parameters" },
    new { Name = "GetAwaiterShouldNotBeGeneric", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetAwaiter' method should not be generic" },
    new { Name = "GetAwaiterShouldReturnAwaiterType", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetAwaiter' method has an unsupported return type" },
    new { Name = "AwaitableTypeShouldHaveGetAwaiterMethod", ExceptionType = "ArgumentException", Args = 1, Message = "Awaitable type '{0}' should have a 'GetAwaiter' method." },
    new { Name = "AwaiterTypeShouldImplementINotifyCompletion", ExceptionType = "ArgumentException", Args = 1, Message = "Awaiter type '{0}' should implement 'INotifyCompletion'" },
    new { Name = "AwaiterTypeShouldHaveIsCompletedProperty", ExceptionType = "ArgumentException", Args = 1, Message = "Awaiter type '{0}' should have an 'IsCompleted' property with a 'get' accessor" },
    new { Name = "AwaiterIsCompletedShouldReturnBool", ExceptionType = "ArgumentException", Args = 1, Message = "The 'IsCompleted' property on awaiter type '{0}' should return 'Boolean'" },
    new { Name = "AwaiterIsCompletedShouldNotBeIndexer", ExceptionType = "ArgumentException", Args = 1, Message = "The 'IsCompleted' property on awaiter type '{0}' should not have indexer parameters" },
    new { Name = "AwaiterTypeShouldHaveGetResultMethod", ExceptionType = "ArgumentException", Args = 1, Message = "Awaiter type '{0}' should have a 'GetResult' method" },
    new { Name = "AwaiterGetResultTypeInvalid", ExceptionType = "ArgumentException", Args = 1, Message = "The 'GetResult' method on awaiter type '{0}' has an unsupported return type" },
    new { Name = "DynamicAwaitNoGetAwaiter", ExceptionType = "ArgumentException", Args = 0, Message = "Dynamically bound await operations cannot have a 'GetAwaiter' expression." },
    new { Name = "DynamicAwaitNoIsCompleted", ExceptionType = "ArgumentException", Args = 0, Message = "Dynamically bound await operations cannot have an 'IsCompleted' property." },
    new { Name = "DynamicAwaitNoGetResult", ExceptionType = "ArgumentException", Args = 0, Message = "Dynamically bound await operations cannot have a 'GetResult' method." },
    new { Name = "GetAwaiterExpressionOneParameter", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetAwaiter' expression should have one parameter." },
    new { Name = "AsyncLambdaCantHaveByRefParameter", ExceptionType = "ArgumentException", Args = 1, Message = "Parameter '{0}' is passed by reference which is not supported in asynchronous lambda expressions" },
    new { Name = "AsyncLambdaInvalidReturnType", ExceptionType = "ArgumentException", Args = 1, Message = "Return type '{0}' is not valid for an asynchronous lambda expression" },
    new { Name = "AwaitForbiddenHere", ExceptionType = "InvalidOperationException", Args = 1, Message = "Await expression cannot occur in '{0}'" },
    new { Name = "LockNeedsReferenceType", ExceptionType = "ArgumentException", Args = 1, Message = "An expression of type '{0}' can't be used as a lock" },
    new { Name = "ConversionNeedsOneParameter", ExceptionType = "ArgumentException", Args = 0, Message = "The conversion lambda should have one parameter" },
    new { Name = "ConversionInvalidArgument", ExceptionType = "ArgumentException", Args = 2, Message = "A collection element of type '{0}' cannot be assigned to the conversion lambda parameter of type '{1}'" },
    new { Name = "ConversionInvalidResult", ExceptionType = "ArgumentException", Args = 2, Message = "The conversion lambda result type '{0}' cannot be assigned to loop iteration variable type '{1}'" },
    new { Name = "EnumeratorShouldHaveCurrentProperty", ExceptionType = "ArgumentException", Args = 1, Message = "Enumerator type '{0}' should have a 'Current' property with a 'get' accessor" },
    new { Name = "EnumeratorShouldHaveMoveNextMethod", ExceptionType = "ArgumentException", Args = 1, Message = "Enumerator type '{0}' should have a 'MoveNext' method with a 'Boolean' return type" },
    new { Name = "MoreThanOneIEnumerableFound", ExceptionType = "ArgumentException", Args = 1, Message = "Collection type '{0}' has multiple implementations of 'IEnumerable<T>'" },
    new { Name = "NoEnumerablePattern", ExceptionType = "ArgumentException", Args = 1, Message = "Collection type '{0}' has no valid enumerable pattern" },
    new { Name = "InvalidInitializer", ExceptionType = "ArgumentException", Args = 0, Message = "Initializers should be assignments to variables" },
    new { Name = "DuplicateLabels", ExceptionType = "ArgumentException", Args = 0, Message = "Break and continue lables should be different" },
    new { Name = "ConditionalAccessRequiresNonStaticMember", ExceptionType = "ArgumentException", Args = 0, Message = "Conditional access expressions require non-static members or extension methods." },
    new { Name = "ConditionalAccessRequiresReadableProperty", ExceptionType = "ArgumentException", Args = 0, Message = "Conditional access expressions require readable properties." },
    new { Name = "TooManyArguments", ExceptionType = "ArgumentException", Args = 0, Message = "Too many arguments have been specified." },
    new { Name = "ExtensionMethodRequiresInstance", ExceptionType = "ArgumentException", Args = 0, Message = "Conditional call expressions for extensions methods should specify an instance expression." },
    new { Name = "InvalidSwitchType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid governing type for a switch statement." },
    new { Name = "DuplicateTestValue", ExceptionType = "ArgumentException", Args = 1, Message = "The test value '{0}' occurs more than once." },
    new { Name = "SwitchCantHaveNullCase", ExceptionType = "ArgumentException", Args = 1, Message = "A 'null' test value cannot be used in a switch statement with governing type '{0}'." },
    new { Name = "SwitchCaseHasIncompatibleType", ExceptionType = "ArgumentException", Args = 2, Message = "A test value with type '{0}' cannot be used in a swich statement with governing type '{1}'." },
    new { Name = "TestValuesShouldHaveConsistentType", ExceptionType = "ArgumentException", Args = 0, Message = "All specified test values should have the same type." },
    new { Name = "SwitchBreakLabelShouldBeVoid", ExceptionType = "ArgumentException", Args = 0, Message = "The break label of a switch statement should be of type 'void'." },
    new { Name = "InvalidGotoCase", ExceptionType = "InvalidOperationException", Args = 1, Message = "A 'goto case {0}' statement was found but the containing switch statement has no such label." },
    new { Name = "InvalidGotoDefault", ExceptionType = "InvalidOperationException", Args = 0, Message = "A 'goto default' statement was found but the containing switch statement has no default label." },
    new { Name = "GotoCanOnlyBeReducedInSwitch", ExceptionType = "InvalidOperationException", Args = 0, Message = "A 'goto case' or 'goto default' statement node can only be reduced when embedded in a switch statement node." },
    new { Name = "InvalidConditionalReceiverType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for a conditional receiver." },
    new { Name = "InvalidConditionalReceiverExpressionType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for a receiver in a conditional access expression." },
    new { Name = "ConditionalReceiverTypeMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "Type '{0}' of the receiver expression is not compatible with non-null type '{1}' of the conditional receiver." },
    new { Name = "InvalidCompoundAssignment", ExceptionType = "ArgumentException", Args = 2, Message = "Compound assignment operation '{0}' is not supported for type '{1}'." },
    new { Name = "InvalidCompoundAssignmentWithOperands", ExceptionType = "ArgumentException", Args = 3, Message = "Compound assignment operation '{0}' is not supported for operands of type '{1}' and '{2}'." },
    new { Name = "InvalidUnaryAssignmentWithOperands", ExceptionType = "ArgumentException", Args = 2, Message = "Unary assignment operation '{0}' is not supported for an operand of type '{1}'." },
    new { Name = "TypeMustNotBeByRef", ExceptionType = "ArgumentException", Args = 0, Message = "Type must not be ByRef" },
    new { Name = "TypeMustNotBePointer", ExceptionType = "ArgumentException", Args = 0, Message = "Type must not be a pointer type" },
    new { Name = "InvalidNullCoalescingAssignmentArguments", ExceptionType = "ArgumentException", Args = 0, Message = "Compound assignment operation of type 'NullCoalescingAssign' does not support custom methods or conversion operations." },
    new { Name = "InvalidInterpolatedStringType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for an interpolated string. Supported types are string, FormattableString, or IFormattable." },
    new { Name = "InvalidFromEndIndexOperandType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for an index operand. Supported types are int or int?." },
    new { Name = "InvalidFromEndIndexMethod", ExceptionType = "ArgumentException", Args = 0, Message = "The specified method is not valid to construct an object of type Index." },
    new { Name = "InvalidIndexType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid index type. Supported types are Index or Index?." },
    new { Name = "InvalidRangeOperandType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for a range operand. Supported types are Index or Index?." },
    new { Name = "InvalidRangeMethod", ExceptionType = "ArgumentException", Args = 0, Message = "The specified method is not valid to construct an object of type Range." },
    new { Name = "InvalidRangeType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid range type. Supported types are Range or Range?." },
    new { Name = "InvalidIndexerAccessArgumentType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for an 'IndexerAccess' argument. Supported types are Index or Range." },
    new { Name = "InvalidLengthOrCountPropertyType", ExceptionType = "ArgumentException", Args = 1, Message = "Property '{0}' should be of type int." },
    new { Name = "InvalidIndexMember", ExceptionType = "ArgumentException", Args = 1, Message = "Member '{0}' is not a valid member for an indexer. Supported member types are MethodInfo or PropertyInfo." },
    new { Name = "InvalidSliceMember", ExceptionType = "ArgumentException", Args = 1, Message = "Member '{0}' is not a valid member for a slice method." },
    new { Name = "InvalidIndexerParameterType", ExceptionType = "ArgumentException", Args = 1, Message = "Indexer '{0}' does not have an 'int' parameter type." },
    new { Name = "SliceMethodMustNotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "Slice method '{0}' should be an instance method." },
    new { Name = "InvalidSliceParameters", ExceptionType = "ArgumentException", Args = 1, Message = "Slice method '{0}' should be have exactly two parameters of type 'int'." },
    new { Name = "InvalidTupleType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid tuple type." },
    new { Name = "InvalidTupleArgumentCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of arguments does not match the number of components of tuple type '{0}'." },
    new { Name = "InvalidTupleArgumentNamesCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of argument names does not match the number of components of tuple type '{0}'." },
    new { Name = "TupleComponentCountMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "The arity of tuple type '{0}' does not match the arity of tuple type '{1}'." },
    new { Name = "InvalidElementConversionCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of element conversion expressions does not match tuple arity '{0}'." },
    new { Name = "InvalidEqualityCheckCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of equality check expressions does not match tuple arity '{0}'." },
    new { Name = "NotAMemberOfAnyType", ExceptionType = "ArgumentException", Args = 1, Message = "'{0}' is not a member of any type." },
    new { Name = "WithExpressionCannotHaveCloneForValueType", ExceptionType = "ArgumentException", Args = 1, Message = "A 'with' expression for value type '{0}' cannot specify a 'Clone' method." },
    new { Name = "WithExpressionShouldHaveClone", ExceptionType = "ArgumentException", Args = 1, Message = "A 'with' expression for type '{0}' should specify a 'Clone' method." },
    new { Name = "CloneMethodShouldHaveNoParameters", ExceptionType = "ArgumentException", Args = 1, Message = "Clone method '{0}' should have no parameters." },
    new { Name = "CloneMethodMustNotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "Clone method '{0}' should be an instance method." },
    new { Name = "CloneMethodShouldReturnCompatibleType", ExceptionType = "ArgumentException", Args = 2, Message = "Clone method '{0}' should return a type that can be converted to '{1}'." },
    new { Name = "MemberInitializerMemberMustNotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "Member '{0}' used in a 'MemberInitializer' cannot be static." },
    new { Name = "MemberInitializerMemberMustBeWriteable", ExceptionType = "ArgumentException", Args = 1, Message = "Member '{0}' used in a 'MemberInitializer' must be writeable." },
    new { Name = "NoAnonymousTypeConstructorFound", ExceptionType = "ArgumentException", Args = 1, Message = "No suitable constructor found for type '{0}' using the specified members." },
    new { Name = "CannotHaveNullablePatternType", ExceptionType = "ArgumentException", Args = 0, Message = "A pattern can never produce a value of a nullable type." },
    new { Name = "PatternInputAndNarrowedTypeShouldMatch", ExceptionType = "ArgumentException", Args = 1, Message = "The input and narrowed type for a pattern of type '{0}' should be equal." },
    new { Name = "CannotAssignPatternResultToVariable", ExceptionType = "ArgumentException", Args = 2, Message = "The variable type '{0}' should be equal to the pattern result type '{1}'." },
    new { Name = "PatternTypeMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "The pattern type '{0}' is not compatible with a subpattern type '{1}'." },
    new { Name = "InvalidBinaryPatternType", ExceptionType = "ArgumentException", Args = 1, Message = "The pattern type '{0}' is not a valid binary pattern type." },
    new { Name = "InvalidRelationalPatternType", ExceptionType = "ArgumentException", Args = 1, Message = "The pattern type '{0}' is not a valid relational pattern type." },
    new { Name = "InvalidPatternConstantType", ExceptionType = "ArgumentException", Args = 1, Message = "The type '{0}' cannot be used for a constant in a pattern." },
    new { Name = "InvalidRelationalPatternConstantType", ExceptionType = "ArgumentException", Args = 1, Message = "The type '{0}' cannot be used for a constant in a relational pattern." },
    new { Name = "CannotUsePatternConstantNaN", ExceptionType = "ArgumentException", Args = 0, Message = "The value NaN cannot be used for a constant in a relational pattern." },
    new { Name = "NullValueShouldUseObjectType", ExceptionType = "ArgumentException", Args = 0, Message = "A null pattern should use a constant of type object." },
    new { Name = "CannotUseNullValueInRelationalPattern", ExceptionType = "ArgumentException", Args = 0, Message = "A null value cannot be used in a relational pattern." },
    new { Name = "ITupleGetLengthShouldReturnInt32", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetLengthMethod' of an 'ITuple' pattern should return an integer value." },
    new { Name = "ITupleGetItemShouldReturnObject", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetItemMethod' of an 'ITuple' pattern should return an object of type Object." },
    new { Name = "ITuplePositionalPatternCannotHaveField", ExceptionType = "ArgumentException", Args = 1, Message = "The 'ITuple' positional subpattern with index '{0}' cannot have a field specified." },
    new { Name = "ITuplePositionalPatternCannotHaveParameter", ExceptionType = "ArgumentException", Args = 1, Message = "The 'ITuple' positional subpattern with index '{0}' cannot have a parameter specified." },
    new { Name = "ITuplePositionalPatternInvalidInputType", ExceptionType = "ArgumentException", Args = 2, Message = "The 'ITuple' positional subpattern with index '{0}' has type '{1}'. Only type Object is supported." },
    new { Name = "InvalidPositionalPattern", ExceptionType = "ArgumentException", Args = 0, Message = "A positional pattern should either be applied to a tuple type or provide a Deconstruct method." },
    new { Name = "InvalidPositionalPatternCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of positional subpatterns does not match the number of components in input type '{0}'." },
    new { Name = "DeconstructShouldReturnVoid", ExceptionType = "ArgumentException", Args = 1, Message = "Deconstruct method '{0}' should return void." },
    new { Name = "DeconstructParameterShouldBeOut", ExceptionType = "ArgumentException", Args = 2, Message = "Parameter '{0}' on Deconstruct method '{1}' should be an out parameter." },
    new { Name = "DeconstructExtensionMethodMissingThis", ExceptionType = "ArgumentException", Args = 1, Message = "Deconstruct method '{0}' should have at least one parameter." },
    new { Name = "TupleFieldIndexMustBePositive", ExceptionType = "ArgumentException", Args = 0, Message = "A tuple field index must be positive." },
    new { Name = "PositionalPatternParameterMustBeOnMethod", ExceptionType = "ArgumentException", Args = 1, Message = "The '{0}' parameter must be declared on a method used for deconstruction." },
    new { Name = "PositionalPatternParameterMustBeOut", ExceptionType = "ArgumentException", Args = 1, Message = "The '{0}' parameter must be an out parameter used for deconstruction." },
    new { Name = "PropertyPatternMemberShouldNotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "The property pattern member '{0}' should not be static." },
    new { Name = "PropertyPatternMemberShouldBeReadable", ExceptionType = "ArgumentException", Args = 1, Message = "The property pattern member '{0}' should be readable." },
    new { Name = "PropertyPatternMemberShouldNotBeIndexer", ExceptionType = "ArgumentException", Args = 1, Message = "The property pattern member '{0}' should not be an indexer property." },
    new { Name = "PropertyPatternMemberIsNotCompatibleWithReceiver", ExceptionType = "ArgumentException", Args = 2, Message = "The property pattern member '{0}' is not compatible with a receiver of type '{1}'." },
    new { Name = "PositionalPatternWithDeconstructMethodCannotSpecifyField", ExceptionType = "ArgumentException", Args = 0, Message = "A positional pattern using a Deconstruct method cannot specify a tuple field." },
    new { Name = "PositionalPatternParameterIsNotDeclaredOnDeconstructMethod", ExceptionType = "ArgumentException", Args = 2, Message = "The '{0}' parameter is not declared on the '{1}' method." },
    new { Name = "PositionalPatternParameterShouldOnlyBeUsedOnce", ExceptionType = "ArgumentException", Args = 1, Message = "The '{0}' parameter is used more than once." },
    new { Name = "PositionalPatternWithDeconstructMethodShouldSpecifyAllParameters", ExceptionType = "ArgumentException", Args = 0, Message = "Either all or none of the Deconstruct method parameters should be specified." },
    new { Name = "PositionalPatternWithTupleCannotSpecifyParameter", ExceptionType = "ArgumentException", Args = 0, Message = "A positional pattern for a tuple type cannot specify a Deconstruct method parameter." },
    new { Name = "PositionalPatternTupleIndexOutOfRange", ExceptionType = "ArgumentException", Args = 2, Message = "The tuple field index '{0}' is out of range for a tuple of cardinality '{1}'." },
    new { Name = "PositionalPatternTupleIndexShouldOnlyBeUsedOnce", ExceptionType = "ArgumentException", Args = 1, Message = "The tuple field index '{0}' is used more than once." },
    new { Name = "PositionalPatternWithTupleShouldSpecifyAllIndices", ExceptionType = "ArgumentException", Args = 0, Message = "Either all or none of the tuple fields should be specified." },
};

var escape = new Func<string, string>(s => s.Replace("<", "&lt;").Replace(">", "&gt;"));
#>
using System;

namespace Microsoft.CSharp.Expressions
{
    /// <summary>
    /// Strongly-typed and parameterized exception factory.
    /// </summary>
    internal static partial class Error
    {
<#
foreach (var error in errors)
{
    var pars = string.Join(", ", Enumerable.Range(0, error.Args).Select(i => "object p" + i));
    var args = string.Join(", ", Enumerable.Range(0, error.Args).Select(i => "p" + i));
    var strArgs = error.Args > 0 ? "(" + args + ")" : "";
    var msg = escape(error.Message);
#>
        /// <summary>
        /// <#=error.ExceptionType#> with message like "<#=msg#>"
        /// </summary>
        internal static Exception <#=error.Name#>(<#=pars#>)
        {
            return new <#=error.ExceptionType#>(Strings.<#=error.Name#><#=strArgs#>);
        }

<#
}
#>
    }

    /// <summary>
    /// Strongly-typed and parameterized string resources.
    /// </summary>
    internal static partial class Strings
    {
<#
foreach (var error in errors)
{
    var pars = string.Join(", ", Enumerable.Range(0, error.Args).Select(i => "object p" + i));
    var args = string.Join(", ", Enumerable.Range(0, error.Args).Select(i => "p" + i));
    if (error.Args > 0)
    {
        pars = "(" + pars + ")";
    }
    var msg = escape(error.Message);
#>
        /// <summary>
        /// A string like "<#=msg#>"
        /// </summary>
        internal static string <#=error.Name#><#=pars#>
        {
<#
    if (error.Args == 0)
    {
#>
            get
            {
                return SR.<#=error.Name#>;
            }
<#
    }
    else
    {
#>
            return SR.Format(SR.<#=error.Name#>, <#=args#>);
<#
    }
#>
        }

<#
}
#>
    }
}

namespace System
{
    internal static partial class SR
    {
<#
foreach (var error in errors)
{
    var msg = escape(error.Message);
#>
        public const string <#=error.Name#> = "<#=msg#>";
<#
}
#>
    }
}