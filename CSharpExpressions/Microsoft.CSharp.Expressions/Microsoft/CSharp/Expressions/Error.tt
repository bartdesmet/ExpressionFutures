// Prototyping extended expression trees for C#.
//
// bartde - October 2015

#nullable enable

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var errors = new[]
{
    new { Name = "ParameterNotDefinedForMethod", ExceptionType = "ArgumentException", Args = 2, Message = "Parameter '{0}' is not defined for method '{1}'." },
    new { Name = "ParameterIndexOutOfBounds", ExceptionType = "ArgumentException", Args = 2, Message = "Parameter index '{0}' is out of bounds for method '{1}'." },
    new { Name = "ExpressionTypeDoesNotMatchParameter", ExceptionType = "ArgumentException", Args = 2, Message = "Expression of type '{0}' cannot be used for parameter of type '{1}'." },
    new { Name = "DuplicateParameterBinding", ExceptionType = "ArgumentException", Args = 1, Message = "Parameter '{0}' has multiple bindings." },
    new { Name = "UnboundParameter", ExceptionType = "ArgumentException", Args = 1, Message = "Non-optional parameter '{0}' has no binding." },
    new { Name = "NonStaticConstructorRequired", ExceptionType = "ArgumentException", Args = 0, Message = "A non-static constructor is required." },
    new { Name = "PropertyDoesNotHaveGetAccessor", ExceptionType = "ArgumentException", Args = 1, Message = "The property '{0}' has no 'get' accessor." },
    new { Name = "PropertyDoesNotHaveSetAccessor", ExceptionType = "ArgumentException", Args = 1, Message = "The property '{0}' has no 'set' accessor." },
    new { Name = "AccessorCannotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "A non-static 'get' accessor is required for property '{0}'." },
    new { Name = "RankMismatch", ExceptionType = "ArgumentException", Args = 0, Message = "The number of indexes specified does not match the array rank." },
    new { Name = "IndexOutOfRange", ExceptionType = "ArgumentOutOfRangeException", Args = 0, Message = "The specified index is out of range." },
    new { Name = "BoundCannotBeLessThanZero", ExceptionType = "ArgumentException", Args = 0, Message = "An array dimension cannot be less than 0." },
    new { Name = "ArrayBoundsElementCountMismatch", ExceptionType = "ArgumentException", Args = 0, Message = "The number of elements does not match the length of the array." },
    new { Name = "GetAwaiterShouldTakeZeroParameters", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetAwaiter' method should take zero parameters." },
    new { Name = "GetAwaiterShouldNotBeGeneric", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetAwaiter' method should not be generic." },
    new { Name = "GetAwaiterShouldReturnAwaiterType", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetAwaiter' method has an unsupported return type." },
    new { Name = "AwaitableTypeShouldHaveGetAwaiterMethod", ExceptionType = "ArgumentException", Args = 1, Message = "Awaitable type '{0}' should have a 'GetAwaiter' method." },
    new { Name = "AwaiterTypeShouldImplementINotifyCompletion", ExceptionType = "ArgumentException", Args = 1, Message = "Awaiter type '{0}' should implement 'INotifyCompletion'." },
    new { Name = "AwaiterTypeShouldHaveIsCompletedProperty", ExceptionType = "ArgumentException", Args = 1, Message = "Awaiter type '{0}' should have an 'IsCompleted' property with a 'get' accessor." },
    new { Name = "AwaiterIsCompletedShouldReturnBool", ExceptionType = "ArgumentException", Args = 1, Message = "The 'IsCompleted' property on awaiter type '{0}' should return 'Boolean'." },
    new { Name = "AwaiterIsCompletedShouldNotBeIndexer", ExceptionType = "ArgumentException", Args = 1, Message = "The 'IsCompleted' property on awaiter type '{0}' should not have indexer parameters." },
    new { Name = "AwaiterTypeShouldHaveGetResultMethod", ExceptionType = "ArgumentException", Args = 1, Message = "Awaiter type '{0}' should have a 'GetResult' method." },
    new { Name = "AwaiterGetResultTypeInvalid", ExceptionType = "ArgumentException", Args = 1, Message = "The 'GetResult' method on awaiter type '{0}' has an unsupported return type." },
    new { Name = "DynamicAwaitNoGetAwaiter", ExceptionType = "ArgumentException", Args = 0, Message = "Dynamically bound await operations cannot have a 'GetAwaiter' expression." },
    new { Name = "DynamicAwaitNoIsCompleted", ExceptionType = "ArgumentException", Args = 0, Message = "Dynamically bound await operations cannot have an 'IsCompleted' property." },
    new { Name = "DynamicAwaitNoGetResult", ExceptionType = "ArgumentException", Args = 0, Message = "Dynamically bound await operations cannot have a 'GetResult' method." },
    new { Name = "GetAwaiterExpressionOneParameter", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetAwaiter' expression should have one parameter." },
    new { Name = "AsyncLambdaCantHaveByRefParameter", ExceptionType = "ArgumentException", Args = 1, Message = "Parameter '{0}' is passed by reference which is not supported in asynchronous lambda expressions." },
    new { Name = "AsyncLambdaInvalidReturnType", ExceptionType = "ArgumentException", Args = 1, Message = "Return type '{0}' is not valid for an asynchronous lambda expression." },
    new { Name = "AwaitForbiddenHere", ExceptionType = "InvalidOperationException", Args = 1, Message = "Await expression cannot occur in '{0}'." },
    new { Name = "LockNeedsReferenceType", ExceptionType = "ArgumentException", Args = 1, Message = "An expression of type '{0}' can't be used as a lock." },
    new { Name = "ConversionNeedsOneParameter", ExceptionType = "ArgumentException", Args = 0, Message = "The conversion lambda should have one parameter." },
    new { Name = "ConversionInvalidArgument", ExceptionType = "ArgumentException", Args = 2, Message = "A collection element of type '{0}' cannot be assigned to the conversion lambda parameter of type '{1}'." },
    new { Name = "ConversionInvalidResult", ExceptionType = "ArgumentException", Args = 2, Message = "The conversion lambda result type '{0}' cannot be assigned to loop iteration variable type '{1}'." },
    new { Name = "EnumeratorShouldHaveCurrentProperty", ExceptionType = "ArgumentException", Args = 1, Message = "Enumerator type '{0}' should have a 'Current' property with a 'get' accessor." },
    new { Name = "EnumeratorShouldHaveMoveNextMethod", ExceptionType = "ArgumentException", Args = 1, Message = "Enumerator type '{0}' should have a 'MoveNext' method with a 'Boolean' return type." },
    new { Name = "MoreThanOneIEnumerableFound", ExceptionType = "ArgumentException", Args = 1, Message = "Collection type '{0}' has multiple implementations of 'IEnumerable<T>'." },
    new { Name = "NoEnumerablePattern", ExceptionType = "ArgumentException", Args = 1, Message = "Collection type '{0}' has no valid enumerable pattern." },
    new { Name = "InvalidInitializer", ExceptionType = "ArgumentException", Args = 0, Message = "Initializers should be assignments to variables." },
    new { Name = "DuplicateLabels", ExceptionType = "ArgumentException", Args = 0, Message = "Break and continue lables should be different." },
    new { Name = "ConditionalAccessRequiresNonStaticMember", ExceptionType = "ArgumentException", Args = 0, Message = "Conditional access expressions require non-static members or extension methods." },
    new { Name = "ConditionalAccessRequiresReadableProperty", ExceptionType = "ArgumentException", Args = 0, Message = "Conditional access expressions require readable properties." },
    new { Name = "TooManyArguments", ExceptionType = "ArgumentException", Args = 0, Message = "Too many arguments have been specified." },
    new { Name = "ExtensionMethodRequiresInstance", ExceptionType = "ArgumentException", Args = 0, Message = "Conditional call expressions for extensions methods should specify an instance expression." },
    new { Name = "InvalidSwitchType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid governing type for a switch statement." },
    new { Name = "DuplicateTestValue", ExceptionType = "ArgumentException", Args = 1, Message = "The test value '{0}' occurs more than once." },
    new { Name = "SwitchCantHaveNullCase", ExceptionType = "ArgumentException", Args = 1, Message = "A 'null' test value cannot be used in a switch statement with governing type '{0}'." },
    new { Name = "SwitchCaseHasIncompatibleType", ExceptionType = "ArgumentException", Args = 2, Message = "A test value with type '{0}' cannot be used in a swich statement with governing type '{1}'." },
    new { Name = "TestValuesShouldHaveConsistentType", ExceptionType = "ArgumentException", Args = 0, Message = "All specified test values should have the same type." },
    new { Name = "SwitchBreakLabelShouldBeVoid", ExceptionType = "ArgumentException", Args = 0, Message = "The break label of a switch statement should be of type 'void'." },
    new { Name = "SwitchLabelTargetShouldBeVoid", ExceptionType = "ArgumentException", Args = 0, Message = "The label of a switch case should be of type 'void'." },
    new { Name = "InvalidGotoCase", ExceptionType = "InvalidOperationException", Args = 1, Message = "A 'goto case {0}' statement was found but the containing switch statement has no such label." },
    new { Name = "InvalidGotoDefault", ExceptionType = "InvalidOperationException", Args = 0, Message = "A 'goto default' statement was found but the containing switch statement has no default label." },
    new { Name = "GotoCanOnlyBeReducedInSwitch", ExceptionType = "InvalidOperationException", Args = 0, Message = "A 'goto case' or 'goto default' statement node can only be reduced when embedded in a switch statement node." },
    new { Name = "InvalidConditionalReceiverType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for a conditional receiver." },
    new { Name = "InvalidConditionalReceiverExpressionType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for a receiver in a conditional access expression." },
    new { Name = "ConditionalReceiverTypeMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "Type '{0}' of the receiver expression is not compatible with non-null type '{1}' of the conditional receiver." },
    new { Name = "InvalidCompoundAssignment", ExceptionType = "ArgumentException", Args = 2, Message = "Compound assignment operation '{0}' is not supported for type '{1}'." },
    new { Name = "InvalidCompoundAssignmentWithOperands", ExceptionType = "ArgumentException", Args = 3, Message = "Compound assignment operation '{0}' is not supported for operands of type '{1}' and '{2}'." },
    new { Name = "InvalidUnaryAssignmentWithOperands", ExceptionType = "ArgumentException", Args = 2, Message = "Unary assignment operation '{0}' is not supported for an operand of type '{1}'." },
    new { Name = "TypeMustNotBeByRef", ExceptionType = "ArgumentException", Args = 0, Message = "Type must not be ByRef." },
    new { Name = "TypeMustNotBePointer", ExceptionType = "ArgumentException", Args = 0, Message = "Type must not be a pointer type." },
    new { Name = "InvalidNullCoalescingAssignmentArguments", ExceptionType = "ArgumentException", Args = 0, Message = "Compound assignment operation of type 'NullCoalescingAssign' does not support custom methods or conversion operations." },
    new { Name = "InvalidInterpolatedStringType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for an interpolated string. Supported types are string, FormattableString, or IFormattable." },
    new { Name = "InvalidFromEndIndexOperandType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for an index operand. Supported types are int or int?." },
    new { Name = "InvalidFromEndIndexMethod", ExceptionType = "ArgumentException", Args = 0, Message = "The specified method is not valid to construct an object of type Index." },
    new { Name = "InvalidIndexType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid index type. Supported types are Index or Index?." },
    new { Name = "InvalidRangeOperandType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for a range operand. Supported types are Index or Index?." },
    new { Name = "InvalidRangeMethod", ExceptionType = "ArgumentException", Args = 0, Message = "The specified method is not valid to construct an object of type Range." },
    new { Name = "InvalidRangeType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid range type. Supported types are Range or Range?." },
    new { Name = "InvalidIndexerAccessArgumentType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid type for an 'IndexerAccess' argument. Supported types are Index or Range." },
    new { Name = "InvalidLengthOrCountPropertyType", ExceptionType = "ArgumentException", Args = 1, Message = "Property '{0}' should be of type int." },
    new { Name = "InvalidIndexMember", ExceptionType = "ArgumentException", Args = 1, Message = "Member '{0}' is not a valid member for an indexer. Supported member types are MethodInfo or PropertyInfo." },
    new { Name = "InvalidSliceMember", ExceptionType = "ArgumentException", Args = 1, Message = "Member '{0}' is not a valid member for a slice method." },
    new { Name = "InvalidIndexerParameterType", ExceptionType = "ArgumentException", Args = 1, Message = "Indexer '{0}' does not have an 'int' parameter type." },
    new { Name = "SliceMethodMustNotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "Slice method '{0}' should be an instance method." },
    new { Name = "InvalidSliceParameters", ExceptionType = "ArgumentException", Args = 1, Message = "Slice method '{0}' should be have exactly two parameters of type 'int'." },
    new { Name = "InvalidTupleType", ExceptionType = "ArgumentException", Args = 1, Message = "Type '{0}' is not a valid tuple type." },
    new { Name = "InvalidTupleArgumentCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of arguments does not match the number of components of tuple type '{0}'." },
    new { Name = "InvalidTupleArgumentNamesCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of argument names does not match the number of components of tuple type '{0}'." },
    new { Name = "TupleComponentCannotBeVoid", ExceptionType = "ArgumentException", Args = 0, Message = "The type of a tuple component cannot be void." },
    new { Name = "TupleComponentCountMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "The arity of tuple type '{0}' does not match the arity of tuple type '{1}'." },
    new { Name = "InvalidElementConversionCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of element conversion expressions does not match tuple arity '{0}'." },
    new { Name = "InvalidEqualityCheckCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of equality check expressions does not match tuple arity '{0}'." },
    new { Name = "NotAMemberOfAnyType", ExceptionType = "ArgumentException", Args = 1, Message = "'{0}' is not a member of any type." },
    new { Name = "WithExpressionCannotHaveCloneForValueType", ExceptionType = "ArgumentException", Args = 1, Message = "A 'with' expression for value type '{0}' cannot specify a 'Clone' method." },
    new { Name = "WithExpressionShouldHaveClone", ExceptionType = "ArgumentException", Args = 1, Message = "A 'with' expression for type '{0}' should specify a 'Clone' method." },
    new { Name = "CloneMethodShouldHaveNoParameters", ExceptionType = "ArgumentException", Args = 1, Message = "Clone method '{0}' should have no parameters." },
    new { Name = "CloneMethodMustNotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "Clone method '{0}' should be an instance method." },
    new { Name = "CloneMethodShouldReturnCompatibleType", ExceptionType = "ArgumentException", Args = 2, Message = "Clone method '{0}' should return a type that can be converted to '{1}'." },
    new { Name = "MemberInitializerMemberMustNotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "Member '{0}' used in a 'MemberInitializer' cannot be static." },
    new { Name = "MemberInitializerMemberMustNotBeIndexer", ExceptionType = "ArgumentException", Args = 1, Message = "Member '{0}' used in a 'MemberInitializer' cannot be an indexer." },
    new { Name = "MemberInitializerMemberMustBeWriteable", ExceptionType = "ArgumentException", Args = 1, Message = "Member '{0}' used in a 'MemberInitializer' must be writeable." },
    new { Name = "NoAnonymousTypeConstructorFound", ExceptionType = "ArgumentException", Args = 1, Message = "No suitable constructor found for type '{0}' using the specified members." },
    new { Name = "CannotHaveNullablePatternType", ExceptionType = "ArgumentException", Args = 0, Message = "A pattern can never produce a value of a nullable type." },
    new { Name = "PatternInputAndNarrowedTypeShouldMatch", ExceptionType = "ArgumentException", Args = 1, Message = "The input and narrowed type for a pattern of type '{0}' should be equal." },
    new { Name = "CannotAssignPatternResultToVariable", ExceptionType = "ArgumentException", Args = 2, Message = "The variable type '{0}' should be equal to the pattern result type '{1}'." },
    new { Name = "PatternTypeMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "The pattern type '{0}' is not compatible with a subpattern type '{1}'." },
    new { Name = "InvalidBinaryPatternType", ExceptionType = "ArgumentException", Args = 1, Message = "The pattern type '{0}' is not a valid binary pattern type." },
    new { Name = "InvalidRelationalPatternType", ExceptionType = "ArgumentException", Args = 1, Message = "The pattern type '{0}' is not a valid relational pattern type." },
    new { Name = "InvalidPatternConstantType", ExceptionType = "ArgumentException", Args = 1, Message = "The type '{0}' cannot be used for a constant in a pattern." },
    new { Name = "InvalidRelationalPatternConstantType", ExceptionType = "ArgumentException", Args = 1, Message = "The type '{0}' cannot be used for a constant in a relational pattern." },
    new { Name = "CannotUsePatternConstantNaN", ExceptionType = "ArgumentException", Args = 0, Message = "The value NaN cannot be used for a constant in a relational pattern." },
    new { Name = "NullValueShouldUseObjectType", ExceptionType = "ArgumentException", Args = 0, Message = "A null pattern should use a constant of type object." },
    new { Name = "CannotUseNullValueInRelationalPattern", ExceptionType = "ArgumentException", Args = 0, Message = "A null value cannot be used in a relational pattern." },
    new { Name = "ITupleGetLengthShouldReturnInt32", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetLengthMethod' of an 'ITuple' pattern should return an integer value." },
    new { Name = "ITupleGetItemShouldReturnObject", ExceptionType = "ArgumentException", Args = 0, Message = "The 'GetItemMethod' of an 'ITuple' pattern should return an object of type Object." },
    new { Name = "ITuplePositionalPatternCannotHaveField", ExceptionType = "ArgumentException", Args = 1, Message = "The 'ITuple' positional subpattern with index '{0}' cannot have a field specified." },
    new { Name = "ITuplePositionalPatternCannotHaveParameter", ExceptionType = "ArgumentException", Args = 1, Message = "The 'ITuple' positional subpattern with index '{0}' cannot have a parameter specified." },
    new { Name = "ITuplePositionalPatternInvalidInputType", ExceptionType = "ArgumentException", Args = 2, Message = "The 'ITuple' positional subpattern with index '{0}' has type '{1}'. Only type Object is supported." },
    new { Name = "InvalidPositionalPattern", ExceptionType = "ArgumentException", Args = 0, Message = "A positional pattern should either be applied to a tuple type or provide a Deconstruct method." },
    new { Name = "InvalidPositionalPatternCount", ExceptionType = "ArgumentException", Args = 1, Message = "The number of positional subpatterns does not match the number of components in input type '{0}'." },
    new { Name = "DeconstructShouldReturnVoid", ExceptionType = "ArgumentException", Args = 1, Message = "Deconstruct method '{0}' should return void." },
    new { Name = "DeconstructParameterShouldBeOut", ExceptionType = "ArgumentException", Args = 2, Message = "Parameter '{0}' on Deconstruct method '{1}' should be an out parameter." },
    new { Name = "DeconstructExtensionMethodMissingThis", ExceptionType = "ArgumentException", Args = 1, Message = "Deconstruct method '{0}' should have at least one parameter." },
    new { Name = "TupleFieldIndexMustBePositive", ExceptionType = "ArgumentException", Args = 0, Message = "A tuple field index must be positive." },
    new { Name = "PositionalPatternParameterMustBeOnMethod", ExceptionType = "ArgumentException", Args = 1, Message = "The '{0}' parameter must be declared on a method used for deconstruction." },
    new { Name = "PositionalPatternParameterMustBeOut", ExceptionType = "ArgumentException", Args = 1, Message = "The '{0}' parameter must be an out parameter used for deconstruction." },
    new { Name = "PropertyPatternMemberShouldNotBeStatic", ExceptionType = "ArgumentException", Args = 1, Message = "The property pattern member '{0}' should not be static." },
    new { Name = "PropertyPatternMemberShouldBeReadable", ExceptionType = "ArgumentException", Args = 1, Message = "The property pattern member '{0}' should be readable." },
    new { Name = "PropertyPatternMemberShouldNotBeIndexer", ExceptionType = "ArgumentException", Args = 1, Message = "The property pattern member '{0}' should not be an indexer property." },
    new { Name = "PropertyPatternMemberIsNotCompatibleWithReceiver", ExceptionType = "ArgumentException", Args = 2, Message = "The property pattern member '{0}' is not compatible with a receiver of type '{1}'." },
    new { Name = "PositionalPatternWithDeconstructMethodCannotSpecifyField", ExceptionType = "ArgumentException", Args = 0, Message = "A positional pattern using a Deconstruct method cannot specify a tuple field." },
    new { Name = "PositionalPatternParameterIsNotDeclaredOnDeconstructMethod", ExceptionType = "ArgumentException", Args = 2, Message = "The '{0}' parameter is not declared on the '{1}' method." },
    new { Name = "PositionalPatternParameterShouldOnlyBeUsedOnce", ExceptionType = "ArgumentException", Args = 1, Message = "The '{0}' parameter is used more than once." },
    new { Name = "PositionalPatternWithDeconstructMethodShouldSpecifyAllParameters", ExceptionType = "ArgumentException", Args = 0, Message = "Either all or none of the Deconstruct method parameters should be specified." },
    new { Name = "PositionalPatternWithTupleCannotSpecifyParameter", ExceptionType = "ArgumentException", Args = 0, Message = "A positional pattern for a tuple type cannot specify a Deconstruct method parameter." },
    new { Name = "PositionalPatternTupleIndexOutOfRange", ExceptionType = "ArgumentException", Args = 2, Message = "The tuple field index '{0}' is out of range for a tuple of cardinality '{1}'." },
    new { Name = "PositionalPatternTupleIndexShouldOnlyBeUsedOnce", ExceptionType = "ArgumentException", Args = 1, Message = "The tuple field index '{0}' is used more than once." },
    new { Name = "PositionalPatternWithTupleShouldSpecifyAllIndices", ExceptionType = "ArgumentException", Args = 0, Message = "Either all or none of the tuple fields should be specified." },
    new { Name = "SwitchExpressionTypeShouldNotBeVoid", ExceptionType = "ArgumentException", Args = 0, Message = "The type of a switch expression should not be void." },
    new { Name = "SwitchExpressionArmPatternInputNotCompatibleWithSwitchExpressionInput", ExceptionType = "ArgumentException", Args = 3, Message = "The switch expression arm at index '{0}' has a pattern input type '{1}' which is not compatible with the switch expression input type '{2}'." },
    new { Name = "SwitchExpressionArmValueNotCompatibleWithSwitchExpressionResult", ExceptionType = "ArgumentException", Args = 3, Message = "The switch expression arm at index '{0}' has a value of type '{1}' which is not compatible with the switch expression result type '{2}'." },
    new { Name = "WhenClauseShouldBeBoolean", ExceptionType = "ArgumentException", Args = 0, Message = "The type of a when clause should be Boolean." },
    new { Name = "SwitchExpressionArmValueShouldNotBeVoid", ExceptionType = "ArgumentException", Args = 0, Message = "The value of a switch expression arm should not be void." },
    new { Name = "ConversionCannotReturnVoid", ExceptionType = "ArgumentException", Args = 0, Message = "A conversion cannot return void." },
    new { Name = "ConversionShouldHaveOneParameter", ExceptionType = "ArgumentException", Args = 0, Message = "A conversion lambda expression should have a single parameter." },
    new { Name = "DeconstructionShouldReturnVoid", ExceptionType = "ArgumentException", Args = 0, Message = "A deconstruction lambda expression should return void." },
    new { Name = "DeconstructionShouldHaveThreeOrMoreParameters", ExceptionType = "ArgumentException", Args = 0, Message = "A deconstruction lambda expression should have at least three parameters, i.e. one for the input, and at least two for components returned by the deconstruction." },
    new { Name = "DeconstructionParameterShouldBeByRef", ExceptionType = "ArgumentException", Args = 1, Message = "The deconstruction lambda expression parameter at position '{0}' represents an output of the deconstruction and should be passed by reference." },
    new { Name = "DeconstructionParameterCountShouldMatchConversionCount", ExceptionType = "ArgumentException", Args = 0, Message = "The number of deconstruction output parameter should match the number of elements conversions." },
    new { Name = "DeconstructionParameterNotAssignableToConversion", ExceptionType = "ArgumentException", Args = 3, Message = "The deconstruction output parameter at index '{0}' of type '{1}' is not assignable to the corresponding element conversion's input type '{2}'." },
    new { Name = "DeconstructingAssignmentStructureMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "The left hand side and the deconstructing conversion of the assignment do not match structurally at depth '{0}' and component '{1}'." },
    new { Name = "DeconstructingAssignmentTypeMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "The computed result tuple type '{0}' does not match the specified expression type '{1}'." },
    new { Name = "DeconstructingComponentAndConversionIncompatible", ExceptionType = "ArgumentException", Args = 4, Message = "The left hand side of type '{0}' and the right hand side of type '{1}' are not assignment compatible in the deconstruction assignment at depth '{2}' and component '{3}'." },
    new { Name = "InvalidUsingStatement", ExceptionType = "ArgumentException", Args = 0, Message = "A using statement should either have a single expression or a declaration list." },
    new { Name = "UsingVariableDeclarationsShouldBeConsistentlyTyped", ExceptionType = "ArgumentException", Args = 0, Message = "All variables declared in a using statement should have the same type." },
    new { Name = "UsingVariableNotInScope", ExceptionType = "ArgumentException", Args = 1, Message = "The variable '{0}' specified in the local declaration should be explicitly included in the variables of the using statement." },
    new { Name = "UsingDisposeShouldReturnVoid", ExceptionType = "ArgumentException", Args = 0, Message = "The Dispose method of a using statement should return void." },
    new { Name = "UsingPatternDisposeShouldHaveOneParameter", ExceptionType = "ArgumentException", Args = 0, Message = "A pattern dispose lambda for a using statement should have one parameter." },
    new { Name = "UsingPatternDisposeInputNotCompatibleWithResource", ExceptionType = "ArgumentException", Args = 2, Message = "The input type '{0}' of the pattern dispose lambda is not compatible with the resource type '{1}' of the using statement." },
    new { Name = "CatchVariableNotInScope", ExceptionType = "ArgumentException", Args = 1, Message = "The variable '{0}' specified in the catch block should be explicitly included in the variables of the catch block." },
    new { Name = "CatchTypeNotEquivalentWithVariableType", ExceptionType = "ArgumentException", Args = 2, Message = "The catch block exception type '{0}' is not equivalent to the variable type '{1}'." },
    new { Name = "DuplicateLabelInSwitchStatement", ExceptionType = "ArgumentException", Args = 1, Message = "The label '{0}' is used in multiple switch sections." },
    new { Name = "DuplicateLabelInSwitchSection", ExceptionType = "ArgumentException", Args = 1, Message = "The label '{0}' is used more than once in the switch section." },
    new { Name = "SwitchValueTypeDoesNotMatchPatternInputType", ExceptionType = "ArgumentException", Args = 2, Message = "The pattern input type '{0}' is not compatible with the switch value type '{1}'." },
    new { Name = "InconsistentPatternInputType", ExceptionType = "ArgumentException", Args = 2, Message = "The pattern input type '{0}' is not consistent with other pattern input types '{1}' in the same switch section." },
    new { Name = "FoundMoreThanOneDefaultLabel", ExceptionType = "ArgumentException", Args = 0, Message = "A switch statement should contain at most one default case." },
    new { Name = "EmptyFormatSpecifier", ExceptionType = "ArgumentException", Args = 0, Message = "A string interpolation format string cannot be empty." },
    new { Name = "MoreThanOneSlicePattern", ExceptionType = "ArgumentException", Args = 0, Message = "A list pattern can have at most one slice subpattern." },
    new { Name = "ElementTypeCannotBeVoid", ExceptionType = "ArgumentException", Args = 0, Message = "The type returned by the index access expression cannot be void." },
    new { Name = "LengthAccessShouldHaveOneParameter", ExceptionType = "ArgumentException", Args = 0, Message = "The length access lambda expression should have a single parameter." },
    new { Name = "LengthAccessShouldReturnInt32", ExceptionType = "ArgumentException", Args = 0, Message = "The length access lambda expression should have an 'Int32' return type." },
    new { Name = "IndexerAccessShouldHaveTwoParameters", ExceptionType = "ArgumentException", Args = 0, Message = "The indexer access lambda expression should have two parameters." },
    new { Name = "LengthAccessParameterShouldHaveCollectionType", ExceptionType = "ArgumentException", Args = 1, Message = "The parameter of the length access lambda expression should match the collection type '{0}'." },
    new { Name = "IndexerAccessFirstParameterShouldHaveCollectionType", ExceptionType = "ArgumentException", Args = 1, Message = "The first parameter of the indexer access lambda expression should match the collection type '{0}'." },
    new { Name = "IndexerAccessSecondParameterInvalidType", ExceptionType = "ArgumentException", Args = 1, Message = "The second parameter of the indexer access lambda expression should be of type '{0}'." },
    new { Name = "ListPatternInputTypeInvalid", ExceptionType = "ArgumentException", Args = 2, Message = "The non-nullable list pattern input type '{0}' should match collection type '{1}'." },
    new { Name = "ForEachNeedsOneOrMoreVariables", ExceptionType = "ArgumentException", Args = 0, Message = "A foreach statement requires at least one iteration variable." },
    new { Name = "ForEachCollectionTypeNotCompatibleWithCollectionExpression", ExceptionType = "ArgumentException", Args = 2, Message = "The collection type '{0}' is not compatible with the type '{1}' of the collection expression." },
    new { Name = "ForEachDeconstructionNotSupportedWithOneVariable", ExceptionType = "ArgumentException", Args = 0, Message = "A foreach statement with a deconstruction step requires more than one iteration variable." },
    new { Name = "ForEachDeconstructionRequiredForMultipleVariables", ExceptionType = "ArgumentException", Args = 0, Message = "A foreach statement with more than one iteration variables requires a deconstruction step." },
    new { Name = "ForEachDeconstructionShouldHaveOneParameter", ExceptionType = "ArgumentException", Args = 0, Message = "The deconstruction lambda expression for a foreach statement should have one parameter." },
    new { Name = "ForEachDeconstructionShouldReturnTuple", ExceptionType = "ArgumentException", Args = 1, Message = "The type '{0}' returned by the deconstruction lambda expression is not a tuple type." },
    new { Name = "ForEachDeconstructionComponentMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "The tuple type '{0}' returned by the deconstruction lambda expression has an arity '{1}' that does not match the number of iteration variables." },
    new { Name = "ForEachDeconstructionComponentNotAssignableToVariable", ExceptionType = "ArgumentException", Args = 4, Message = "The type '{0}' of the tuple component at index '{1}' returned by the deconstruction lambda cannot be assigned to variable '{2}' of type '{3}'." },
    new { Name = "MethodNotEventAccessor", ExceptionType = "ArgumentException", Args = 2, Message = "The method '{1}' on type '{0}' is not an event accessor." },
    new { Name = "EventDoesNotHaveAccessor", ExceptionType = "ArgumentException", Args = 1, Message = "The event '{0}' does not have an accessor." },
    new { Name = "OnlyStaticEventsHaveNullInstance", ExceptionType = "ArgumentException", Args = 0, Message = "Only static events have an object expression." },
    new { Name = "EventNotDefinedForType", ExceptionType = "ArgumentException", Args = 2, Message = "The event '{0}' is not declared on type '{1}'." },
    new { Name = "EventAccessorShouldReturnVoid", ExceptionType = "ArgumentException", Args = 0, Message = "An event accessor method should return void." },
    new { Name = "EventAccessorShouldHaveOneParameter", ExceptionType = "ArgumentException", Args = 0, Message = "An event accessor method should have one parameter." },
    new { Name = "EventAccessorParameterTypeMismatch", ExceptionType = "ArgumentException", Args = 2, Message = "The handler expression type '{0}' is not assignable to the event accessor parameter of type '{1}'." },
    new { Name = "InvalidInterpolatedStringHandlerType", ExceptionType = "ArgumentException", Args = 1, Message = "The '{0}' is not a valid interpolated string handler type." },
    new { Name = "InterpolatedStringHandlerTypeNotAssignable", ExceptionType = "ArgumentException", Args = 2, Message = "The construction lambda return type '{0}' is not assignable to interpolated string handler type '{1}'." },
    new { Name = "InvalidInterpolatedStringHandlerConstructionArgCount", ExceptionType = "ArgumentException", Args = 0, Message = "An interpolated string handler construction should have at least two parameters for 'literalLength' and 'formattedCount'." },
    new { Name = "InvalidInterpolatedStringHandlerInt32ParameterType", ExceptionType = "ArgumentException", Args = 2, Message = "The '{0}' parameter representing '{1}' should be of type Int32." },
    new { Name = "InvalidInterpolatedStringHandlerAppendReturnType", ExceptionType = "ArgumentException", Args = 1, Message = "The type '{0}' is not a valid return type for an append call. Only 'void' and 'bool' are supported." },
    new { Name = "InconsistentInterpolatedStringHandlerAppendReturnType", ExceptionType = "ArgumentException", Args = 0, Message = "The return types of the append calls is inconsistent." },
    new { Name = "InvalidInterpolatedStringHandlerAppendArgCount", ExceptionType = "ArgumentException", Args = 0, Message = "An interpolated string handler append call should have at least one parameter for the handler instance." },
    new { Name = "InvalidInterpolatedStringHandlerAppendFirstArgType", ExceptionType = "ArgumentException", Args = 2, Message = "The type '{0}' of the first parameter of the interpolated string handler append call is not compatible with the interpolated string handler type '{1}'." },
    new { Name = "InvalidStringHandlerConversionOperandType", ExceptionType = "ArgumentException", Args = 1, Message = "The type '{0}' is not valid for an interpolated string handler conversion." },
    new { Name = "InvalidStringHandlerConversionOperandNodeType", ExceptionType = "ArgumentException", Args = 1, Message = "The node of type '{0}' is not valid as the operand for an interpolated string handler conversion." },
    new { Name = "InvalidInterpolatedStringHandlerArgumentIndex", ExceptionType = "ArgumentException", Args = 1, Message = "The argument index '{0}' is not valid." },
    new { Name = "NotEnoughInterpolatedStringHandlerConstructionParameters", ExceptionType = "ArgumentException", Args = 2, Message = "The number of parameters '{0}' for the interpolated string handler construction is insufficient for an argument count of '{1}' (need at least 'literalLength' and 'formattedCount')." },
    new { Name = "TooManyInterpolatedStringHandlerConstructionParameters", ExceptionType = "ArgumentException", Args = 2, Message = "The number of parameters '{0}' for the interpolated string handler construction is too large for an argument count of '{1}' (can have at most one extra 'out bool' parameter)." },
    new { Name = "InvalidInterpolatedStringHandlerConstructionOutBoolParameter", ExceptionType = "ArgumentException", Args = 1, Message = "The last parameter of type '{0}' for the interpolated string handler construction is not valid for an 'out bool shouldAppend' trailing parameter." },
    new { Name = "AppendLambdaShouldHaveFirstByRefParameter", ExceptionType = "ArgumentException", Args = 1, Message = "The append lambda expression's first parameter '{0}' denoting the interpolated string handler should be passed by reference." },
    new { Name = "AppendLiteralLambdaShouldHaveTwoParameters", ExceptionType = "ArgumentException", Args = 0, Message = "The lambda expression representing the 'AppendLiteral' operation should take 2 parameters." },
    new { Name = "AppendLiteralLambdaShouldTakeStringParameter", ExceptionType = "ArgumentException", Args = 1, Message = "The lambda expression representing the 'AppendLiteral' operation has a second parameter of type '{0}' which is invalid and should be 'string'." },
    new { Name = "AppendFormattedLambdaInvalidParameterCount", ExceptionType = "ArgumentException", Args = 0, Message = "The lambda expression representing the 'AppendFormatted' operation should take 2, 3, or 4 parameters." },
    new { Name = "AppendFormattedLambdaSecondParameterShouldBeNonVoid", ExceptionType = "ArgumentException", Args = 0, Message = "The lambda expression representing the 'AppendFormatted' operation should have a second parameter denoting a non-void value." },
    new { Name = "AppendFormattedLambdaThirdParameterShouldBeIntOrString", ExceptionType = "ArgumentException", Args = 1, Message = "The lambda expression representing the 'AppendFormatted' operation has a third parameter of type '{0}' and should be 'int' to denote an alignment or 'string' to denote a format." },
    new { Name = "AppendFormattedLambdaThirdParameterShouldBeInt", ExceptionType = "ArgumentException", Args = 1, Message = "The lambda expression representing the 'AppendFormatted' operation has a third parameter of type '{0}' and should be 'int' to denote an alignment." },
    new { Name = "AppendFormattedLambdaFourthParameterShouldBeString", ExceptionType = "ArgumentException", Args = 1, Message = "The lambda expression representing the 'AppendFormatted' operation has a fourth parameter of type '{0}' and should be 'string' to denote a format." },
    new { Name = "IncorrectNumberOfAppendsForInterpolatedString", ExceptionType = "ArgumentException", Args = 2, Message = "The number of append operations '{0}' does not match the number of interpolations '{1}' in the interpolated string operand." },
    new { Name = "InvalidAppendFormattedParameterCount", ExceptionType = "ArgumentException", Args = 2, Message = "The number of parameters '{0}' for the 'AppendFormatted' operation does not match the expected number '{1}' for the interpolated string's interpolation." },
    new { Name = "InvalidAppendFormattedValueType", ExceptionType = "ArgumentException", Args = 2, Message = "The type '{0}' of the 'value' parameter for the 'AppendFormatted' operation is not compatible with the expected type '{1}' for the interpolated string's interpolation value." },
    new { Name = "InvalidAlignmentParameterType", ExceptionType = "ArgumentException", Args = 1, Message = "The type '{0}' is invalid for the alignment parameter and should be 'int'." },
    new { Name = "InvalidFormatParameterType", ExceptionType = "ArgumentException", Args = 1, Message = "The type '{0}' is invalid for the format parameter and should be 'string'." },
    new { Name = "GetEnumeratorShouldHaveSingleParameter", ExceptionType = "ArgumentException", Args = 0, Message = "The 'getEnumerator' lambda should have a single parameter." },
    new { Name = "InvalidGetEnumeratorFirstArgType", ExceptionType = "ArgumentException", Args = 2, Message = "The type '{0}' of the first parameter of the 'getEnumerator' lambda is not compatible with the collection type '{1}'." },
    new { Name = "MoveNextShouldHaveSingleParameter", ExceptionType = "ArgumentException", Args = 0, Message = "The 'moveNext' lambda should have a single parameter." },
    new { Name = "InvalidMoveNextFirstArgType", ExceptionType = "ArgumentException", Args = 2, Message = "The type '{0}' of the first parameter of the 'moveNext' lambda is not compatible with the enumerator type '{1}'." },
    new { Name = "MoveNextShouldHaveBooleanReturnType", ExceptionType = "ArgumentException", Args = 0, Message = "The 'moveNext' lambda should return 'bool'." },
    new { Name = "PropertyShouldNotBeIndexer", ExceptionType = "ArgumentException", Args = 1, Message = "The '{0}' property should not have indexer parameters." },
    new { Name = "PropertyShouldNotReturnVoid", ExceptionType = "ArgumentException", Args = 1, Message = "The '{0}' property should not have a 'void' type." },
    new { Name = "CurrentConversionShouldHaveSingleParameter", ExceptionType = "ArgumentException", Args = 0, Message = "The 'currentConversion' lambda should have a single parameter." },
    new { Name = "InvalidCurrentConversionFirstArgType", ExceptionType = "ArgumentException", Args = 2, Message = "The type '{0}' of the first parameter of the 'currentConversion' lambda is not compatible with the collection type '{1}'." },
    new { Name = "InvalidCurrentReturnType", ExceptionType = "ArgumentException", Args = 2, Message = "The element type '{0}' is not compatible with the type '{1}' returned by the 'Current' property." },
    new { Name = "AsyncEnumerationNotSupportedForArray", ExceptionType = "ArgumentException", Args = 0, Message = "Asynchronous enumeration is not supported for array types." },
    new { Name = "AsyncEnumerationNotSupportedForString", ExceptionType = "ArgumentException", Args = 0, Message = "Asynchronous enumeration is not supported on type 'String'." },
    new { Name = "AmbiguousEnumeratorMethod", ExceptionType = "ArgumentException", Args = 2, Message = "The '{0}.{1}' method is ambiguous." },
    new { Name = "ListPatternShouldHaveCollectionTypeOrVariable", ExceptionType = "ArgumentException", Args = 0, Message = "List pattern should have a collection type or a variable." },
};

var escape = new Func<string, string>(s => s.Replace("<", "&lt;").Replace(">", "&gt;"));
#>
using System;

namespace Microsoft.CSharp.Expressions
{
    /// <summary>
    /// Strongly-typed and parameterized exception factory.
    /// </summary>
    internal static partial class Error
    {
<#
foreach (var error in errors)
{
    var pars = string.Join(", ", Enumerable.Range(0, error.Args).Select(i => "object? p" + i));
    var args = string.Join(", ", Enumerable.Range(0, error.Args).Select(i => "p" + i));
    var strArgs = error.Args > 0 ? "(" + args + ")" : "";
    var msg = escape(error.Message);
#>
        /// <summary>
        /// <#=error.ExceptionType#> with message like "<#=msg#>"
        /// </summary>
        internal static Exception <#=error.Name#>(<#=pars#>) => new <#=error.ExceptionType#>(Strings.<#=error.Name#><#=strArgs#>);

<#
}
#>
    }

    /// <summary>
    /// Strongly-typed and parameterized string resources.
    /// </summary>
    internal static partial class Strings
    {
<#
foreach (var error in errors)
{
    var pars = string.Join(", ", Enumerable.Range(0, error.Args).Select(i => "object? p" + i));
    var args = string.Join(", ", Enumerable.Range(0, error.Args).Select(i => "p" + i));
    if (error.Args > 0)
    {
        pars = "(" + pars + ")";
    }
    var msg = escape(error.Message);
#>
        /// <summary>
        /// A string like "<#=msg#>"
        /// </summary>
<#
    if (error.Args == 0)
    {
#>
        internal static string <#=error.Name#><#=pars#> => SR.<#=error.Name#>;
<#
    }
    else
    {
#>
        internal static string <#=error.Name#><#=pars#> => SR.Format(SR.<#=error.Name#>, <#=args#>);
<#
    }
#>

<#
}
#>
    }
}

namespace System
{
    internal static partial class SR
    {
<#
foreach (var error in errors)
{
    var msg = escape(error.Message);
#>
        public const string <#=error.Name#> = "<#=msg#>";
<#
}
#>
    }
}