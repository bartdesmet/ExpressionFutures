// Prototyping extended expression trees for C#.
//
// bartde - October 2015

#nullable enable

using System;
using System.Linq.Expressions;
using System.Reflection;

using static System.Dynamic.Utils.ContractUtils;
using static System.Dynamic.Utils.ExpressionUtils;

namespace Microsoft.CSharp.Expressions
{
    /// <summary>
    /// Represents an expression that awaits an asynchronous operation.
    /// </summary>
    public partial class AwaitCSharpExpression : UnaryCSharpExpression
    {
        internal AwaitCSharpExpression(Expression operand, AwaitInfo info)
            : base(operand)
        {
            Info = info;
        }

        /// <summary>
        /// Returns the node type of this <see cref="CSharpExpression" />. (Inherited from <see cref="CSharpExpression" />.)
        /// </summary>
        /// <returns>The <see cref="CSharpExpressionType"/> that represents this expression.</returns>
        public sealed override CSharpExpressionType CSharpNodeType => CSharpExpressionType.Await;

        /// <summary>
        /// Gets the static type of the expression that this <see cref="Expression" /> represents. (Inherited from <see cref="Expression"/>.)
        /// </summary>
        /// <returns>The <see cref="Type"/> that represents the static type of the expression.</returns>
        public override Type Type => Info.Type;

        /// <summary>
        /// Gets the GetAwaiter method used to await the asynchronous operation.
        /// </summary>
        public AwaitInfo Info { get; }

        /// <summary>
        /// Dispatches to the specific visit method for this node type.
        /// </summary>
        /// <param name="visitor">The visitor to visit this node with.</param>
        /// <returns>The result of visiting this node.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", Justification = "Following the visitor pattern from System.Linq.Expressions.")]
        protected internal override Expression Accept(CSharpExpressionVisitor visitor) => visitor.VisitAwait(this);

        /// <summary>
        /// Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.
        /// </summary>
        /// <param name="operand">The <see cref="UnaryCSharpExpression.Operand" /> property of the result.</param>
        /// <param name="info">The <see cref="AwaitCSharpExpression.Info"/> property of the result.</param>
        /// <returns>This expression if no children changed, or an expression with the updated children.</returns>
        public AwaitCSharpExpression Update(Expression operand, AwaitInfo info)
        {
            if (operand == Operand && info == Info)
            {
                return this;
            }

            return Rewrite(operand, info);
        }

        /// <summary>
        /// Creates a new expression that is like this one, but using the supplied children.
        /// </summary>
        /// <param name="operand">The <see cref="UnaryCSharpExpression.Operand" /> property of the result.</param>
        /// <param name="info">The <see cref="AwaitCSharpExpression.Info"/> property of the result.</param>
        /// <returns>An expression with the updated children.</returns>
        protected internal virtual AwaitCSharpExpression Rewrite(Expression operand, AwaitInfo info) => CSharpExpression.Await(operand, info);

        /// <summary>
        /// Gets a value that indicates whether the expression tree node can be reduced. 
        /// </summary>
        public override bool CanReduce =>
            // NB: Await nodes can only occur in AsyncLambda expressions and should not get compiled
            //     via the normal expression compiler path of reducing extension nodes. The closest
            //     enclosing AsyncLambda node is responsible for rewriting those.
            //
            // NB: We don't throw from Reduce because it breaks DebugView. By returning false from
            //     this property, we can get the LINQ lambda compiler to bail out upon an attempt to
            //     compile an await expresion without a surrounding async lambda. Unfortunately, it
            //     does so without providing a good error message, which we could only achieve by
            //     throwing from the Reduce method, at the expense of the useful DebugView. Given
            //     that most expressions should be generated by code emitted by the C# compiler, it
            //     seems worth optimizing for the debugging experience.
            false;
    }

    partial class CSharpExpression
    {
        /// <summary>
        /// Creates an <see cref="AwaitCSharpExpression"/> that represents awaiting an asynchronous operation.
        /// </summary>
        /// <param name="operand">An <see cref="Expression" /> that specifies the asynchronous operation to await.</param>
        /// <returns>An instance of the <see cref="AwaitCSharpExpression"/>.</returns>
        public static AwaitCSharpExpression Await(Expression operand)
        {
            RequiresNotNull(operand, nameof(operand));

            RequiresCanRead(operand, nameof(operand));

            return Await(operand, AwaitInfo(operand.Type));
        }

        /// <summary>
        /// Creates an <see cref="AwaitCSharpExpression"/> that represents awaiting an asynchronous operation.
        /// </summary>
        /// <param name="operand">An <see cref="Expression" /> that specifies the asynchronous operation to await.</param>
        /// <param name="getAwaiterMethod">The GetAwaiter method used to await the asynchronous operation.</param>
        /// <returns>An instance of the <see cref="AwaitCSharpExpression"/>.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Awaiter", Justification = "Get a waiter :-)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", Justification = "Done by helper method.")]
        public static AwaitCSharpExpression Await(Expression operand, MethodInfo getAwaiterMethod)
        {
            RequiresNotNull(operand, nameof(operand));

            RequiresCanRead(operand, nameof(operand));

            return Await(operand, AwaitInfo(operand.Type, getAwaiterMethod));
        }

        /// <summary>
        /// Creates an <see cref="AwaitCSharpExpression"/> that represents awaiting an asynchronous operation.
        /// </summary>
        /// <param name="operand">An <see cref="Expression" /> that specifies the asynchronous operation to await.</param>
        /// <param name="info">An <see cref="Microsoft.CSharp.Expressions.AwaitInfo"/> that specifies binding information for the await operation.</param>
        /// <returns>An instance of the <see cref="AwaitCSharpExpression"/>.</returns>
        public static AwaitCSharpExpression Await(Expression operand, AwaitInfo info)
        {
            // NB: This is the overload the C# compiler binds to.

            RequiresNotNull(operand, nameof(operand));
            RequiresNotNull(info, nameof(info));

            RequiresCanRead(operand, nameof(operand));

            info.RequiresCanBind(operand);

            return new AwaitCSharpExpression(operand, info);
        }
    }

    partial class CSharpExpressionVisitor
    {
        /// <summary>
        /// Visits the children of the <see cref="AwaitCSharpExpression" />.
        /// </summary>
        /// <param name="node">The expression to visit.</param>
        /// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", Justification = "Following the visitor pattern from System.Linq.Expressions.")]
        protected internal virtual Expression VisitAwait(AwaitCSharpExpression node) =>
            node.Update(
                Visit(node.Operand),
                VisitAwaitInfo(node.Info)
            );
    }
}
